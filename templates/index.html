<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#ffffff" />
  <meta name="description" content="Epistemiq ‚Äì Verify scientific and factual claims using hybrid AI." />
  <!-- ‚úÖ Favicon and app icons -->
  <link rel="icon" type="image/png" sizes="32x32" href="/static/icons/logo.png">
  <link rel="apple-touch-icon" href="/static/icons/logo.png">
  <link rel="shortcut icon" href="/static/icons/logo.png">
  <meta name="theme-color" content="#0d6efd">
  
  <title>Epistemiq ‚Äì Verify scientific and factual claims using hybrid AI</title>

  <!-- ‚úÖ Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
        crossorigin="anonymous" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" />

  <!-- ‚úÖ Custom Styles -->
  <!-- <link rel="stylesheet" href="templates/static/styles.css" /> -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-H5SNSXX9K0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-H5SNSXX9K0');
</script>


 <script type="module">
  import * as xenova from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.15.0/dist/transformers.min.js";
  window.__tf = xenova;
  console.log("‚úÖ Transformers ESM loaded");
</script>


  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<style>

body {
background-color: #f8f9fa;
color: #212529;
font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}
.container {
max-width: 900px;
padding-top: 20px;
padding-bottom: 50px;
}
.control-card, .claim-card {
background-color: #ffffff;
padding: 2.5rem;
border-radius: 15px;
margin-bottom: 25px;
box-shadow: 0 6px 20px rgba(0,0,0,0.08);
border: 1px solid #e0e0e0;
}
.form-label {
font-weight: 600;
color: #343a40;
margin-bottom: 8px;
}
.form-control, .form-select {
border-radius: 8px;
padding: 0.75rem 1rem;
border: 1px solid #ced4da;
}
.form-control:focus, .form-select:focus {
border-color: #86b7fe;
box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}
.btn-primary {
background-color: #0d6efd;
border-color: #0d6efd;
font-weight: 600;
padding: 0.8rem 1.5rem;
border-radius: 8px;
transition: background-color 0.2s, border-color 0.2s;
}
.btn-primary:hover {
background-color: #0b5ed7;
border-color: #0a58ca;
}
.btn-secondary {
background-color: #6c757d;
border-color: #6c757d;
color: #fff;
font-weight: 500;
border-radius: 8px;
}
.btn-secondary:hover {
background-color: #5c636a;
border-color: #565e64;
}
.btn-success {
background-color: #28a745;
border-color: #28a745;
font-weight: 600;
padding: 0.8rem 1.5rem;
border-radius: 8px;
transition: background-color 0.2s, border-color 0.2s;
}
.btn-success:hover {
background-color: #218838;
border-color: #1e7e34;
}
.btn-info {
background-color: #0dcaf0;
border-color: #0dcaf0;
}
.spinner-border {
width: 1.2rem;
height: 1.2rem;
margin-right: 8px;
}
.claim-card h5 {
font-weight: 700;
color: #0d6efd;
margin-bottom: 1rem;
font-size: 1.5rem;
}
.claim-card p {
font-size: 1.05rem;
line-height: 1.6;
}
.verdict-box, .report-box {
background-color: #e9ecef;
padding: 18px;
border-radius: 10px;
border: 1px solid #dee2e6;
white-space: pre-wrap;
font-family: 'Roboto Mono', 'Courier New', monospace;
font-size: 0.95rem;
line-height: 1.5;
color: #343a40;
overflow-wrap: break-word;
}
.report-box {
background-color: #e8f5ff;
border-color: #cce7ff;
margin-top: 15px;
}
.report-placeholder {
min-height: 50px;
padding-left: 15px;
}
.question-list li {
background-color: #f8f9fa;
border-color: #e9ecef;
margin-bottom: 10px;
border-radius: 8px;
padding: 15px 20px;
display: flex;
flex-direction: column;
align-items: flex-start;
justify-content: space-between;
flex-wrap: wrap;
}
.question-list li span {
flex-grow: 1;
margin-right: 15px;
font-size: 1rem;
line-height: 1.5;
margin-bottom: 10px;
width: 100%;
}
.question-list li button {
flex-shrink: 0;
margin-top: 5px;
}
.source-list li {
word-break: break-all;
margin-bottom: 5px;
font-size: 0.9rem;
}
.source-list a {
color: #0d6efd;
text-decoration: none;
}
.source-list a:hover {
text-decoration: underline;
}
.footer {
margin-top: 5rem;
padding: 2rem 0;
border-top: 1px solid #dee2e6;
font-size: 0.9rem;
color: #6c757d;
}
.alert-danger {
background-color: #f8d7da;
color: #721c24;
border-color: #f5c6cb;
}
.alert-info {
background-color: #d1ecf1;
color: #0c5460;
border-color: #bee5eb;
}
.d-grid button {
height: 55px;
}
.form-check-input.form-switch {
width: 3em;
height: 1.5em;
margin-left: 0.5em;
vertical-align: middle;
background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='rgba%280, 0, 0, 0.25%29'/%3e%3c/svg%3e");
background-position: left center;
border-radius: 1.5em;
transition: background-position .15s ease-in-out;
}
.form-check-input.form-switch:checked {
background-position: right center;
background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e");
}
.form-check-input.form-switch:focus {
box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}
.form-check-label {
vertical-align: middle;
margin-left: 0.5rem;
}
.report-checkbox {
margin-right: 8px;
}
.pdf-selection-section {
background-color: #e8f5e8;
padding: 1.5rem;
border-radius: 10px;
margin-bottom: 20px;
border: 1px solid #c3e6c3;
}
.pdf-selection-list {
max-height: 300px;
overflow-y: auto;
margin-top: 15px;
}
.file-upload-group {
border: 2px dashed #dee2e6;
border-radius: 8px;
padding: 2rem;
text-align: center;
background-color: #f8f9fa;
transition: all 0.3s ease;
}
.file-upload-group:hover {
border-color: #0d6efd;
background-color: #e7f1ff;
}
.file-upload-group.dragover {
border-color: #0d6efd;
background-color: #d4e6ff;
}
.upload-icon {
font-size: 3rem;
color: #6c757d;
margin-bottom: 1rem;
}
.file-input-hidden {
display: none;
}
.preview-image {
max-width: 100%;
max-height: 200px;
margin-top: 1rem;
border-radius: 8px;
}
.table {
width: 100%;
margin: 10px 0;
}
.table-bordered {
border: 1px solid #dee2e6;
}
.table-sm {
font-size: 0.9rem;
}
/* Modal styles for report selection */
.report-selection-list {
max-height: 400px;
overflow-y: auto;
border: 1px solid #dee2e6;
border-radius: 8px;
padding: 15px;
}
.report-selection-item {
padding: 10px;
border-bottom: 1px solid #f8f9fa;
}
.report-selection-item:last-child {
border-bottom: none;
}
/* Compact view for inline reports */
.compact-report {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #e9ecef;
    border-radius: 5px;
    padding: 10px;
    background-color: #e8f5ff;
    font-size: 0.9rem;
}
/* Custom Modal Styles (Vanilla) */
.custom-modal {
display: none;
position: fixed;
z-index: 1050;
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: hidden;
outline: 0;
}
.custom-modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.5);
z-index: 1040;
}
.custom-modal-dialog {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 1050;
width: 90%;
max-width: 1200px;
margin: auto;
animation: custom-modal-animatetop 0.4s;
}
@keyframes custom-modal-animatetop {
from {top: -300px; opacity: 0;}
to {top: 50%; opacity: 1;}
}
.custom-modal-content {
background-color: #e8f5ff;
border: 1px solid #cce7ff;
border-radius: 0.3rem;
box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.5);
position: relative;
display: flex;
flex-direction: column;
width: 100%;
pointer-events: auto;
background-clip: padding-box;
outline: 0;
}
.custom-modal-header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 1rem;
border-bottom: 1px solid #cce7ff;
border-top-left-radius: 0.3rem;
border-top-right-radius: 0.3rem;
background-color: #ffffff;
}
.custom-modal-title {
margin-bottom: 0;
line-height: 1.5;
font-size: 1.25rem;
}
.custom-close-btn {
padding: 1rem;
margin: -1rem -1rem -1rem auto;
background-color: transparent;
border: 0;
font-size: 1.5rem;
font-weight: 700;
line-height: 1;
color: #000;
text-shadow: 0 1px 0 #fff;
opacity: 0.5;
cursor: pointer;
}
.custom-close-btn:hover {
color: #000;
text-decoration: none;
opacity: 0.75;
}
.custom-modal-body {
position: relative;
flex: 1 1 auto;
padding: 1rem;
background-color: #ffffff;
}
.custom-modal-footer {
display: flex;
flex-wrap: wrap;
align-items: center;
justify-content: flex-end;
padding: 0.75rem;
border-top: 1px solid #cce7ff;
border-bottom-right-radius: 0.3rem;
border-bottom-left-radius: 0.3rem;
gap: 0.5rem;
background-color: #ffffff;
}
.custom-btn {
display: inline-block;
font-weight: 400;
color: #212529;
text-align: center;
vertical-align: middle;
cursor: pointer;
user-select: none;
background-color: transparent;
border: 1px solid transparent;
padding: 0.375rem 0.75rem;
font-size: 1rem;
line-height: 1.5;
border-radius: 0.25rem;
transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
margin: 0 0.25rem;
}
.custom-btn-secondary {
color: #fff;
background-color: #6c757d;
border-color: #6c757d;
}
.custom-btn-secondary:hover {
background-color: #5a6268;
border-color: #545b62;
}
.custom-btn-outline-primary {
color: #007bff;
border-color: #007bff;
}
.custom-btn-outline-primary:hover {
color: #fff;
background-color: #007bff;
border-color: #007bff;
}
.body-no-scroll {
overflow: hidden;
}
@media (max-width: 576px) {
.custom-modal-dialog {
width: 95%;
max-width: none;
}
}

.logo-wrapper {
  text-align: center;
}

.logo-wrapper img {
  width: 100px; /* Increase size */
  height: 100px;
  border-radius: 15px; /* Rounded corners */
  object-fit: cover;
  margin-bottom: 10px;
}

.logo-wrapper .tagline {
  font-size: 1rem;
  color: #0A0F2C;
  font-weight: 600;
  margin: 0;
}

#chrome-ai-info {
  box-shadow: 0 0 10px rgba(255, 230, 100, 0.4);
  border-radius: 8px;
}

.chrome-ai-btn button {
  background-color: #fff9e6 !important;
  border-color: #ffe8b3 !important;
  color: #5c4a00 !important;
}
.chrome-ai-btn button:hover {
  background-color: #ffe9a8 !important;
}

.textarea-dim { filter: blur(2px); opacity: .6; }

.ai-pulse {
  display:inline-block;
  width:10px;
  height:10px;
  border-radius:50%;
  background:#000;
  animation: aip 0.8s infinite alternate ease-in-out;
}

@keyframes aip {
  from { opacity:.2; transform:scale(.6); }
  to   { opacity:1; transform:scale(1); }
}

.loading {
  opacity: 0.5;
  pointer-events: none;
}

/* Fix for the History Modal styling */
#historyModal .modal-dialog {
    max-width: 60%; 
    width: 100%;
    margin: 1rem auto; /* Centers it horizontally */
}

#historyList .list-group-item {
    /* Remove max-width here so it fills the modal container naturally */
    width: 100%;
    border-radius: 8px;
    margin-bottom: 8px;
    border: 1px solid #e9ecef;
}

/* ‚ú® Unified User Menu Styles (Fixed Width, Below Button, Uniform Text) */

/* 1. Standardize the Button Size */
.user-menu-btn {
    width: 240px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

.user-menu-btn span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

/* 2. Standardize the Dropdown Position */
.user-menu-dropdown {
    width: 240px !important;
    min-width: 240px !important;
    max-width: 240px !important;
    
    /* üü¢ FORCE POSITION BELOW BUTTON */
    position: absolute !important;
    top: 100% !important; 
    left: 0 !important;
    transform: none !important;
    inset: auto !important; /* Overrides newer Bootstrap positioning */
    margin-top: 6px !important;
    
    text-align: center;
}

/* 3. Uniform Item Styling (Removes colors/bolding) */
.user-menu-dropdown .dropdown-item,
.user-menu-dropdown .dropdown-item-text {
    color: #212529 !important; /* Standard dark text */
    font-weight: 400 !important; /* Normal weight */
    font-size: 0.95rem;
    padding: 0.5rem 1rem;
}

.user-menu-dropdown .dropdown-item:active,
.user-menu-dropdown .dropdown-item:focus {
    background-color: #e9ecef; /* Light gray hover instead of blue */
    color: #212529 !important;
}

/* Email text specific */
.user-menu-dropdown .dropdown-item-text {
    cursor: text;
    user-select: all;
    background: transparent !important;
}

/* ‚ú® Standardized Badge Styles */
.ep-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    padding: 0.25em 0.65em;
    border-radius: 50rem;
    vertical-align: middle;
    margin-left: 8px;
    letter-spacing: 0.3px;
    text-transform: uppercase;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    white-space: nowrap;
    
    /* Tooltip logic setup */
    position: relative;
    cursor: help; 
}

/* üü¢ FIX 1: Allow interaction even if parent button is disabled (Nano Badge) */
.btn:disabled .ep-badge {
    pointer-events: auto;
    cursor: help;
}

/* Tooltip Popup Box */
.ep-badge::after {
    content: attr(data-reason);
    visibility: hidden;
    opacity: 0;
    
    /* üü¢ FIX 2: Layout & Wrapping */
    width: max-content;     /* shrink to fit text */
    max-width: 220px;       /* but cap it so it wraps */
    white-space: normal;    /* allow wrapping */
    
    background-color: #212529; /* Darker, higher contrast */
    color: #fff;
    text-align: left;       /* Easier to read */
    border-radius: 6px;
    padding: 8px 12px;
    
    position: absolute;
    z-index: 1070;          /* Above Bootstrap modals */
    bottom: 140%;           /* Push up slightly more */
    
    /* üü¢ FIX 3: Alignment (Prevent left cut-off) */
    left: 0;                /* Align to left edge of badge */
    transform: none;        /* Remove centering transform */
    
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transition: opacity 0.2s, visibility 0.2s;
    pointer-events: none;
    font-size: 0.75rem;
    line-height: 1.4;
    font-weight: 400;
    text-transform: none;
}

/* Little triangle arrow */
.ep-badge::before {
    content: "";
    visibility: hidden;
    opacity: 0;
    position: absolute;
    top: -5px; 
    left: 10px; /* Align arrow with the left-aligned tooltip */
    border-width: 5px;
    border-style: solid;
    border-color: #212529 transparent transparent transparent;
    transition: opacity 0.2s;
}

/* Show on Hover (Desktop) or Focus (Mobile Tap) */
.ep-badge:hover::after, .ep-badge:focus::after,
.ep-badge:hover::before, .ep-badge:focus::before,
.ep-badge:active::after, .ep-badge:active::before {
    visibility: visible;
    opacity: 1;
}

/* Colors */
.ep-badge-db {
    background-color: #e7f1ff;
    color: #0d6efd;
    border: 1px solid #cce5ff;
}

.ep-badge-nano {
    background-color: #e0f2f1;
    color: #00695c;
    border: 1px solid #b2dfdb;
}

.list-group-item .ep-badge {
    margin-top: -2px; 
}

/* Watermark Logo in Text Area */
#textInput {
    /* 1. Heavy white wash (96% opacity) to make the logo very faint */
    background-image: 
        linear-gradient(rgba(255, 255, 255, 0.90), rgba(255, 255, 255, 0.90)),
        url('https://raw.githubusercontent.com/akebonin/epistemiq/refs/heads/main/templates/static/icons/LOGOTO.PNG');
    
    /* 2. Center the image */
    background-position: center center;
    
    /* 3. 'cover' fills the entire box without distorting the image */
    background-size: cover;
    
    background-repeat: no-repeat;

    resize: none;
}

/* üü¢ FIX 2: Added '#' selector (This fixes the "doesn't work" issue) */
#textInput:focus {
    background-image: none;
    background-color: #fff; 
}

/* Toast Animations */
.toast.show {
    animation: slideInRight 0.3s ease-out forwards;
}

@keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

/* Custom Toast Colors */
.toast-success .toast-header {
    background-color: #d1e7dd;
    color: #0f5132;
}
.toast-error .toast-header {
    background-color: #f8d7da;
    color: #842029;
}

/* Verify Button Styles */
.verify-actions-bar {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.btn-verify-single {
    border: 1px solid #0d6efd;
    color: #0d6efd;
    background: #fff;
    padding: 5px 15px;
    font-size: 0.9rem;
    border-radius: 6px;
    transition: all 0.2s;
}

.btn-verify-single:hover {
    background: #0d6efd;
    color: #fff;
}

.btn-verify-single:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.status-indicator {
    font-size: 0.85rem;
    font-weight: 600;
    margin-left: 10px;
}

/* ‚úÖ NEW: Mobile-friendly Model Badge */
.model-attribution-badge {
    white-space: normal !important;       /* Force text wrapping */
    text-align: left;                     /* Align left for multi-line readability */
    word-break: break-word;               /* Prevent long model IDs from overflowing */
    max-width: 100%;                      /* Ensure it fits in the card */
    line-height: 1.3;
    display: inline-flex;                 /* Flex to align icon */
    align-items: flex-start;              /* Align icon to top line of text */
    gap: 6px;                             /* Space between icon and text */
    
    /* Styling to match Bootstrap 'badge bg-light text-secondary border' but safer */
    background-color: #f8f9fa;
    color: #6c757d;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 6px 10px;
    font-weight: 500;
    font-size: 0.75rem;
    margin-bottom: 8px;
}

.model-attribution-badge i {
    margin-top: 2px; /* Micro-adjustment for icon alignment on multi-line text */
}
  
</style>
</head>
<body>
<div class="container">
<div class="control-card">
    <div class="logo-wrapper mb-4">
    <img src="https://raw.githubusercontent.com/akebonin/epistemiq/refs/heads/main/templates/static/icons/logo.png" alt="epistemiq logo">
    <p class="tagline">Your Compass in the Epistemic Fog</p>
  </div>

<!-- ‚ú® User Block (Unified Style for Logged In & Logged Out) -->
<div id="userAccessBlock" class="text-center mb-3" style="position: relative;">

    <!-- LOGGED OUT DROPDOWN -->
    <div id="userLoggedOutMenu" class="dropdown d-inline-block">
        <button class="btn btn-outline-secondary btn-sm dropdown-toggle user-menu-btn" data-bs-toggle="dropdown">
            <span>Menu</span>
        </button>

        <ul class="dropdown-menu user-menu-dropdown p-0 shadow-sm">
            <li><button class="dropdown-item" id="openFaqBtn_LoggedOut">FAQ</button></li>
            
            <li><hr class="dropdown-divider my-1"></li>
            <li><span class="dropdown-item-text small text-muted pb-0" style="font-size: 0.75rem;">Contact Support:</span></li>
            <li>
                <span class="dropdown-item-text pt-0">epistemiq.ai@gmail.com</span>
            </li>
            <li><hr class="dropdown-divider my-1"></li>
            
            <li><button class="dropdown-item" id="clearNanoCacheBtn_LoggedOut">Clear Chrome AI Cache</button></li>
            <li><button class="dropdown-item" id="loginBtn">Sign In</button></li>
        </ul>
    </div>

    <!-- LOGGED IN DROPDOWN -->
    <div id="userLoggedInMenu" class="dropdown d-none d-inline-block">
        <button class="btn btn-outline-secondary btn-sm dropdown-toggle user-menu-btn" data-bs-toggle="dropdown">
            <span id="userEmail"></span>
        </button>

        <ul class="dropdown-menu user-menu-dropdown p-0 shadow-sm">
            <li><button class="dropdown-item" id="openHistoryBtn">Your Analyses</button></li>
            <li><button class="dropdown-item" id="openFaqBtn_LoggedIn">FAQ</button></li>
            
            <li><hr class="dropdown-divider my-1"></li>
            <li><span class="dropdown-item-text small text-muted pb-0" style="font-size: 0.75rem;">Contact Support:</span></li>
            <li>
                <span class="dropdown-item-text pt-0">epistemiq.ai@gmail.com</span>
            </li>
            <li><hr class="dropdown-divider my-1"></li>

            <li><button class="dropdown-item" id="clearNanoCacheBtn_LoggedIn">Clear Chrome AI Cache</button></li>
        </ul>
    </div>

</div>
  
<form id="analysis-form">
<div class="mb-3">
  <label for="inputMethod" class="form-label">Input method</label>
  <select id="inputMethod" class="form-select">
    <option value="paste">Paste Text</option>
    <option value="url">Provide URL</option>
    <option value="image">Upload Image</option>
    <option value="video">Upload Video</option>
    <option value="video-url">Video URL</option>
  </select>
</div>

<!-- ‚úÖ Chrome AI Info Card -->
<div id="chrome-ai-info" class="alert alert-warning d-none mt-2" role="alert"
     style="background-color:#fff9e6; border-color:#ffe8b3; color:#5c4a00; font-size:0.9rem;">
  
  <!-- Header: Title + Toggle Switch -->
  <div class="d-flex justify-content-between align-items-start mb-2">
    <div>
      ‚öôÔ∏è <strong>Chrome AI Mode</strong>
    </div>
    <div class="form-check form-switch">
      <input class="form-check-input" type="checkbox" id="enableChromeAiToggle" checked style="cursor: pointer;">
      <label class="form-check-label fw-bold" for="enableChromeAiToggle" style="font-size: 0.8rem;">Enabled</label>
    </div>
  </div>

  <!-- Description -->
  <div id="chrome-ai-description">
    üß† Gemini Nano will locally summarize and translate extracted or pasted text before analysis. This will ensure text preprocessing (cleanup, summarization & translation), full data privacy, and reduced backend costs.
  </div>

  <!-- Mode Selection -->
  <div class="mt-2" id="chrome-ai-mode">
    <label class="form-label fw-semibold mb-1" style="font-size:0.8rem;">Processing Strategy</label>
    <select id="chromeMode" class="form-select form-select-sm bg-white">
      <option value="distill">üî¨ Scientific Distillation (Epistemic Mode)</option>
      <option value="accurate">üéØ Standard Summary</option>
      <option value="fast">üèéÔ∏è Fast Cleanup</option>
    </select>
    <div class="form-text text-muted" style="font-size: 0.75rem;">
      "Distillation" removes fluff but keeps all claims, dates, and data points.
    </div>
  </div>
</div>

<!-- ‚Ü©Ô∏è Undo Button (Hidden by default, sits below the button container) -->
<div class="d-flex justify-content-end mt-1">
    <button id="undo-nano-btn" class="btn btn-link btn-sm text-danger d-none" style="text-decoration:none; font-size: 0.85rem;">
        ‚Ü© Undo Changes
    </button>
</div>

<!-- Area for Local AI Keywords -->
<div id="nano-topics-container" class="d-none mt-2">
  <small class="text-muted fw-bold me-2" style="font-size: 0.75rem;">TOPICS DETECTED:</small>
  <div id="nano-topics-list" class="d-inline-block">
    <!-- Badges will be injected here via JS -->
  </div>
</div>
  
<div id="paste-input-group" class="mb-3" style="position:relative;">
  <label for="textInput" class="form-label">Paste article or post content</label>

  <textarea id="textInput" rows="7" class="form-control"
            placeholder="Paste content here..."></textarea>

  <div id="chrome-ai-text" class="mt-2 d-none"></div>
</div>

<div id="url-input-group" class="mb-3 d-none">
<label for="urlInput" class="form-label">Enter article URL</label>
<div class="input-group">
<input id="urlInput" type="text" class="form-control" placeholder="https://example.com">
<button id="fetch-article-btn" class="btn btn-secondary" type="button">
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Fetch Article
</button>
</div>
</div>
<div id="image-input-group" class="mb-3 d-none">
<label class="form-label">Upload Image with Text</label>
<div class="file-upload-group" id="image-upload-area">
<div class="upload-icon">üñºÔ∏è</div>
<h5>Drop image here or click to browse</h5>
<p class="text-muted">Supports JPG, PNG, GIF (Max 10MB)</p>
<input type="file" id="imageInput" class="file-input-hidden" accept="image/*">
<button type="button" class="btn btn-outline-primary" onclick="document.getElementById('imageInput').click()">
Choose Image
</button>
<div id="image-preview" class="mt-3"></div>
</div>
<button id="process-image-btn" class="btn btn-info mt-2 w-100" type="button" disabled>
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Extract Text from Image
</button>
</div>
<div id="video-input-group" class="mb-3 d-none">
<label class="form-label">Upload Video</label>
<div class="file-upload-group" id="video-upload-area">
<div class="upload-icon">üìπ</div>
<h5>Drop video here or click to browse</h5>
<p class="text-muted">Supports MP4, AVI, MOV (Max 50MB)</p>
<input type="file" id="videoInput" class="file-input-hidden" accept="video/*">
<button type="button" class="btn btn-outline-primary" onclick="document.getElementById('videoInput').click()">
Choose Video
</button>
</div>
<button id="process-video-btn" class="btn btn-info mt-2 w-100" type="button" disabled>
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Transcribe Video
</button>
</div>
<div id="video-url-input-group" class="mb-3 d-none">
<label for="videoUrlInput" class="form-label">Enter Video URL</label>
<div class="input-group">
<input id="videoUrlInput" type="text" class="form-control" placeholder="https://youtube.com/watch?v=... or https://vimeo.com/...">
<button id="transcribe-video-url-btn" class="btn btn-secondary" type="button">
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Transcribe Video
</button>
</div>
</div>

<!-- ‚úÖ Model Selector -->
<div class="mb-3">
  <label for="preferredModel" class="form-label">Select Verifier Model</label>
  <select id="preferredModel" class="form-select">
    <option value="x-ai/grok-4.1-fast:free" selected>‚ö° Grok 4.1 (Fast & Smart)</option>
    <option value="google/gemini-2.0-flash-exp:free">üß† Gemini 2.0 Flash Exp (Deep reasoning, step‚Äëby‚Äëstep)</option>
    <option value="google/gemma-3-27b-it:free">üíé Gemma 3 27B (Instruction‚Äëtuned, powerful open model)</option>
    <option value="openai/gpt-oss-20b:free">üîÆ GPT‚ÄëOSS 20B (OpenAI experimental, balanced power)</option>
    <option value="meta-llama/llama-3.3-70b-instruct:free">ü¶ô Llama 3.3 70B (Open Source, strong instruction following)</option>
    <option value="mistralai/mistral-7b-instruct:free">üå™Ô∏è Mistral 7B (Lightweight, efficient, quick replies)</option>
  </select>
  <div class="form-text text-muted" style="font-size: 0.75rem;">
    If your preferred model is busy (429 errors), the system will automatically fall back to the others.
  </div>
</div>
  
<div class="mb-4">
<label for="promptMode" class="form-label">Select Analysis Focus</label>
<select id="promptMode" class="form-select">
<option>General Analysis of Testable Claims</option>
<option>Specific Focus on Scientific Claims</option>
<option>Technology-Focused Extraction</option>
</select>
</div>
<div class="mb-4 form-check form-switch">
<input class="form-check-input" type="checkbox" id="usePapersToggle" checked>
<label class="form-check-label" for="usePapersToggle">üìú Supplement with Semantic Scholar + Crossref + CORE + PubMed data</label>
</div>
<div class="d-grid">
<button id="run-analysis-btn" class="btn btn-primary btn-lg" type="submit">
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Run Analysis
</button>
</div>
</form>
</div>
<div id="results-container"></div>
<!-- Always visible download button -->
<div id="pdf-download-section" class="text-center mt-5">
<button id="download-pdf-btn" class="btn btn-success btn-lg">
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Download Analysis Report (PDF)
</button>

</div>
<footer class="text-center text-muted footer">
From murk to clarity ‚Äî powered by Epistemiq.
</footer>
</div>
<!-- Report Selection Modal -->
<div class="modal fade" id="reportSelectionModal" tabindex="-1" aria-labelledby="reportSelectionModalLabel" aria-hidden="true">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<h5 class="modal-title" id="reportSelectionModalLabel">Select Reports for PDF</h5>
<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
</div>
<div class="modal-body">
<div class="mb-3">
<button id="select-all-reports-modal" class="btn btn-outline-primary btn-sm">Select All</button>
<button id="deselect-all-reports-modal" class="btn btn-outline-secondary btn-sm">Deselect All</button>
</div>
<div id="report-selection-list" class="report-selection-list">
<!-- Dynamic content will be inserted here -->
</div>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
<button id="generate-pdf-from-modal" class="btn btn-success">
<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
Generate PDF
</button>
</div>
</div>
</div>
</div>
<!-- Research Report Modal (Vanilla Implementation) -->
<div id="researchReportModal" class="custom-modal" aria-hidden="true">
<div class="custom-modal-overlay" id="custom-modal-overlay"></div>
<div class="custom-modal-dialog">
<div class="custom-modal-content">
<div class="custom-modal-header">
<h5 class="custom-modal-title" id="researchReportModalLabel">Research Report</h5>
<button type="button" class="custom-close-btn" aria-label="Close">&times;</button>
</div>
<div class="custom-modal-body">
<div id="modal-report-content" class="report-box" style="max-height: 70vh; overflow-y: auto; padding: 1rem; line-height: 1.6; font-size: 1rem;">
<!-- Report content will be inserted here -->
</div>
</div>
<div class="custom-modal-footer">
<button type="button" class="custom-btn custom-btn-secondary custom-close-btn">Close</button>
<button id="copy-report-btn" class="custom-btn custom-btn-outline-primary">Copy to Clipboard</button>
</div>
</div>
</div>
</div>

<!-- LOGIN MODAL -->
<div class="modal fade" id="loginModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">

      <div class="modal-header">
        <h5 class="modal-title">Sign In</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>

      <div class="modal-body">
        <!-- Input Group -->
        <div id="loginInputGroup">
            <input id="loginEmail" type="email" class="form-control" placeholder="Enter your email">
            <div class="form-text text-muted small mt-2">
                <i class="bi bi-info-circle"></i> We will send a magic link to your inbox.
            </div>
        </div>
        
        <!-- Status / Success Message Area -->
        <div id="loginStatus" class="mt-3"></div>
      </div>

      <div class="modal-footer">
        <!-- Button ID remains the same for JS hook -->
        <button class="btn btn-primary w-100" id="sendLoginLink">Send Login Link</button>
      </div>

    </div>
  </div>
</div>

  <!-- üìú User History Modal -->
<div class="modal fade" id="historyModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Your Analyses</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
         <ul id="historyList" class="list-group small"></ul>
      </div>
    </div>
  </div>
</div>

<!-- WELCOME / ONBOARDING MODAL -->
<div class="modal fade" id="welcomeModal" tabindex="-1" aria-labelledby="welcomeModalLabel" aria-hidden="true" data-bs-backdrop="static">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content border-0 shadow-lg">
      <div class="modal-header bg-light border-0">
        <h5 class="modal-title fw-bold text-primary" id="welcomeModalLabel">
          <img src="/static/icons/logo.png" width="24" height="24" class="me-2" alt="">
          Welcome to Epistemiq
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body p-4">
        <p class="lead fs-6 text-muted mb-4">
          Epistemiq is a browser-first <strong>misinformation defense tool</strong>. It extracts claims, summarizes text locally using <strong>Chrome‚Äôs Gemini Nano</strong>, and verifies them using a selection of cloud models, helping you quickly check scientific accuracy.
        </p>

        <div class="d-flex align-items-start mb-3">
          <div class="bg-primary text-white rounded-circle d-flex align-items-center justify-content-center flex-shrink-0 me-3" style="width: 32px; height: 32px; font-weight: bold;">1</div>
          <div>
            <h6 class="fw-bold mb-1">Input Content</h6>
            <p class="small text-muted m-0">Paste text, enter a URL, or upload an Image/Video to extract claims.</p>
          </div>
        </div>

        <div class="d-flex align-items-start mb-3">
          <div class="bg-primary text-white rounded-circle d-flex align-items-center justify-content-center flex-shrink-0 me-3" style="width: 32px; height: 32px; font-weight: bold;">2</div>
          <div>
            <h6 class="fw-bold mb-1">Analyze & Verify</h6>
            <p class="small text-muted m-0">The AI extracts testable claims. You can then verify them individually or in bulk against scientific consensus.</p>
          </div>
        </div>

        <div class="d-flex align-items-start">
          <div class="bg-primary text-white rounded-circle d-flex align-items-center justify-content-center flex-shrink-0 me-3" style="width: 32px; height: 32px; font-weight: bold;">3</div>
          <div>
            <h6 class="fw-bold mb-1">Get the Evidence</h6>
            <p class="small text-muted m-0">We cross-reference claims with <strong>Semantic Scholar, PubMed, CORE & CrossRef</strong> to find real papers.</p>
          </div>
        </div>
      </div>
      <div class="modal-footer border-0 bg-light">
        <button type="button" class="btn btn-primary w-100" id="dismissWelcomeBtn">
          Get Started üöÄ
        </button>
      </div>
    </div>
  </div>
</div>
  
<script>

// ‚úÖ Helper to generate badge HTML string
function getBadgeHtml(type = 'db') {
    if (type === 'nano') {
        return `<span class="ep-badge ep-badge-nano" tabindex="0" data-reason="Data retrieved from prior analysis for performance optimization."><i class="bi bi-cpu"></i> CACHED</span>`;
    }
    // Default to DB/Backend
    return `<span class="ep-badge ep-badge-db" tabindex="0" data-reason="Data retrieved from prior analysis for performance optimization."><i class="bi bi-database-check"></i> CACHED</span>`;
}

const API_BASE = "";
  
document.addEventListener('DOMContentLoaded', () => {
const inputMethodSelect = document.getElementById('inputMethod');
const pasteInputGroup = document.getElementById('paste-input-group');
const urlInputGroup = document.getElementById('url-input-group');
const imageInputGroup = document.getElementById('image-input-group');
const videoInputGroup = document.getElementById('video-input-group');
const videoUrlInputGroup = document.getElementById('video-url-input-group');
const textInput = document.getElementById('textInput');
const urlInput = document.getElementById('urlInput');
const imageInput = document.getElementById('imageInput');
const videoInput = document.getElementById('videoInput');
const videoUrlInput = document.getElementById('videoUrlInput');
const fetchArticleBtn = document.getElementById('fetch-article-btn');
const processImageBtn = document.getElementById('process-image-btn');
const processVideoBtn = document.getElementById('process-video-btn');
const transcribeVideoUrlBtn = document.getElementById('transcribe-video-url-btn');
const analysisForm = document.getElementById('analysis-form');
const runAnalysisBtn = document.getElementById('run-analysis-btn');
const resultsContainer = document.getElementById('results-container');
const pdfDownloadSection = document.getElementById('pdf-download-section');
const downloadPdfBtn = document.getElementById('download-pdf-btn');
const promptModeSelect = document.getElementById('promptMode');
const usePapersToggle = document.getElementById('usePapersToggle');
const imageUploadArea = document.getElementById('image-upload-area');
const videoUploadArea = document.getElementById('video-upload-area');
const imagePreview = document.getElementById('image-preview');

const activeVerifications = new Set();




let analysisId = null;
let generatedReports = [];
let currentImageFile = null;
let currentVideoFile = null;
let currentSourceUrl = null;



  
// --- WELCOME MODAL LOGIC ---
    const hasSeenWelcome = localStorage.getItem('ep_welcome_seen_v1');
    
    if (!hasSeenWelcome) {
        // Show the modal with a slight delay for better UX
        setTimeout(() => {
            const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
            welcomeModal.show();
        }, 800);
    }

    // Handle Dismissal
    document.getElementById('dismissWelcomeBtn').addEventListener('click', () => {
        // Mark as seen in local storage
        localStorage.setItem('ep_welcome_seen_v1', 'true');
        
        // Hide modal
        const modalEl = document.getElementById('welcomeModal');
        const modalInstance = bootstrap.Modal.getInstance(modalEl);
        modalInstance.hide();
    });
    
    // Optional: Reset logic for testing (Run this in console to see it again)
    // localStorage.removeItem('ep_welcome_seen_v1');
  

/**
 * Displays a non-blocking notification.
 * @param {string} message - The text to display.
 * @param {string} type - 'success' (green), 'error' (red), or 'info' (default).
 */
function showToast(message, type = 'info') {
    const container = document.querySelector('.toast-container');
    
    // Icon & Header Config
    let icon = 'bi-info-circle';
    let headerClass = '';
    let title = 'Notification';
    let autoHide = true;
    let delay = 10000; // 10 seconds

    if (type === 'success') {
        icon = 'bi-check-circle-fill text-success';
        headerClass = 'toast-success';
        title = 'Success';
    } else if (type === 'error') {
        icon = 'bi-exclamation-triangle-fill text-danger';
        headerClass = 'toast-error';
        title = 'Error';
        autoHide = false; // Keep errors visible until clicked
    }

    // Create Toast HTML
    const toastId = 'toast-' + Date.now();
    const html = `
      <div id="${toastId}" class="toast ${headerClass}" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
          <i class="bi ${icon} me-2"></i>
          <strong class="me-auto">${title}</strong>
          <small class="text-muted">Just now</small>
          <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
          ${message}
        </div>
      </div>
    `;

    // Inject
    const template = document.createElement('div');
    template.innerHTML = html.trim();
    const toastEl = template.firstChild;
    container.appendChild(toastEl);

    // Initialize Bootstrap Toast
    const bsToast = new bootstrap.Toast(toastEl, {
        autohide: autoHide,
        delay: delay
    });
    bsToast.show();

    // Cleanup DOM after hide
    toastEl.addEventListener('hidden.bs.toast', () => {
        toastEl.remove();
    });
}
  
// ----------------------------------------------------
// 1. Check login status on page load
// ----------------------------------------------------
async function checkAuth() {
  const res = await fetch(`${API_BASE}/auth/me`, {
    credentials: "include"
  });
  const data = await res.json();

  const loginBtn = document.getElementById("loginBtn");
  const userMenu = document.getElementById("userLoggedInMenu");
  const emailSpan = document.getElementById("userEmail");

  if (!loginBtn || !userMenu || !emailSpan) {
    return; // defensive guard
  }

  if (data.authenticated) {
    document.getElementById("userLoggedOutMenu")?.classList.add("d-none");
    document.getElementById("userLoggedInMenu")?.classList.remove("d-none");
    emailSpan.innerText = data.email || "";
} else {
    document.getElementById("userLoggedInMenu")?.classList.add("d-none");
    document.getElementById("userLoggedOutMenu")?.classList.remove("d-none");
}

}

checkAuth();


// ----------------------------------------------------
// 2. Open login modal
// ----------------------------------------------------
document.getElementById("loginBtn").onclick = () => {
  const modal = new bootstrap.Modal(document.getElementById("loginModal"));
  modal.show();
};

// ----------------------------------------------------
// 3. Request magic link (Updated with Spam Warning & Close Button)
// ----------------------------------------------------
document.getElementById("sendLoginLink").onclick = async function() {
  const emailInput = document.getElementById("loginEmail");
  const inputGroup = document.getElementById("loginInputGroup");
  const statusDiv = document.getElementById("loginStatus");
  const btn = document.getElementById("sendLoginLink");
  
  const email = emailInput.value.trim();

  if (!email) {
    statusDiv.innerHTML = '<div class="text-danger small">Please enter a valid email address.</div>';
    return;
  }

  // 1. Loading State
  btn.disabled = true;
  btn.innerText = "Sending...";
  statusDiv.innerHTML = ""; // Clear previous errors

  try {
      const res = await fetch(`${API_BASE}/auth/request-link`, {
        method: "POST",
        credentials: "include",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ email })
      });

      // 2. Success State
      if (res.ok) {
        // Hide the input field to reduce clutter
        inputGroup.style.display = 'none';

        // Show prominent success message with Spam Warning
        statusDiv.innerHTML = `
            <div class="alert alert-success text-center" role="alert">
                <h4 class="alert-heading h6 fw-bold">Link Sent! üöÄ</h4>
                <p class="mb-2">Please check your inbox for the login link.</p>
                <hr>
                <p class="mb-0 small text-start">
                    <i class="bi bi-exclamation-triangle-fill text-warning"></i> 
                    <strong>Important:</strong> If you don't see the email within a minute, 
                    please check your <span class="text-decoration-underline fw-bold">Spam</span> 
                    or <span class="text-decoration-underline fw-bold">Junk</span> folder.
                </p>
            </div>
        `;

        // Change button to "Close" and set it to dismiss modal
        btn.innerText = "Close";
        btn.className = "btn btn-secondary w-100"; // Change color to gray
        btn.disabled = false;
        
        // Remove this click listener and set Bootstrap dismiss attribute
        btn.onclick = null; 
        btn.setAttribute('data-bs-dismiss', 'modal');
      } 
      else {
        // Handle Server Error
        const errData = await res.json();
        throw new Error(errData.error || "Failed to send link");
      }

  } catch (error) {
      // 3. Error State
      console.error(error);
      btn.disabled = false;
      btn.innerText = "Send Login Link";
      statusDiv.innerHTML = `<div class="alert alert-danger small">${error.message || "Error sending link. Please try again."}</div>`;
  }
};

// ----------------------------------------------------
// 4. Process ?token= & ?email= from magic-link
// ----------------------------------------------------
async function processLoginToken() {
  const params = new URLSearchParams(window.location.search);
  if (!params.has("token") || !params.has("email")) return;

  const token = params.get("token");
  const email = params.get("email");

  // Redirect directly to backend GET route
  window.location.href = `${API_BASE}/auth/verify?token=${encodeURIComponent(token)}&email=${encodeURIComponent(email)}`;
}

// Always run on page load
processLoginToken();


// ----------------------------------------------------
// 5. Load user history (Updated)
// ----------------------------------------------------
async function loadHistory() {
  const list = document.getElementById("historyList");
  if (!list) return; 

  const res = await fetch(`${API_BASE}/api/my-analyses`, {
    credentials: "include"
  });

  if (!res.ok) return;

  const data = await res.json();

  list.innerHTML = "";

  if (!data.items || data.items.length === 0) {
    const empty = document.createElement("li");
    empty.className = "list-group-item text-muted text-center bg-transparent border-0";
    empty.textContent = "No saved analyses yet.";
    list.appendChild(empty);
    return;
  }

  // ‚úÖ SORTING FIX: Sort items by date (Newest First)
  data.items.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

  data.items.forEach(item => {
    const li = document.createElement("li");
    li.className = "list-group-item bg-white shadow-sm p-3";

    // format created_at as dd/mm/yy
    let dateLabel = "";
    if (item.created_at) {
      const d = new Date(item.created_at);
      const day = String(d.getDate()).padStart(2, "0");
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const year = String(d.getFullYear()).slice(-2);
      dateLabel = `${day}/${month}/${year}`;
    }

    const safeTitle = item.title || item.mode || "Untitled analysis";
    // Escape basic HTML to prevent XSS in title
    const escapedTitle = safeTitle.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

    li.innerHTML = `
      <div class="d-flex justify-content-between align-items-center mb-2">
        <!-- 1. Title -->
        <strong class="text-wrap text-break me-2">${escapedTitle}</strong>
        
        <!-- 2. Date -->
        <span class="badge bg-light text-dark border flex-shrink-0">${dateLabel}</span>
      </div>
      
      <div class="d-flex gap-2 mt-2">
        <button class="btn btn-sm btn-primary me-2"
          onclick="event.stopPropagation(); loadAnalysis('${item.analysis_id}'); bootstrap.Modal.getInstance(document.getElementById('historyModal')).hide();">
          Open
        </button>

        <button class="btn btn-sm btn-outline-danger"
          onclick="event.stopPropagation(); deleteAnalysis('${item.analysis_id}')">
          Delete
        </button>
      </div>
    `;

    list.appendChild(li);
  });
}

// ----------------------------------------------------
// 6. Delete analysis
// ----------------------------------------------------
async function deleteAnalysis(id) {
  await fetch(`${API_BASE}/api/delete-analysis/${id}`, {
    method: "DELETE",
    credentials: "include"
  });
  loadHistory();
}

// ----------------------------------------------------
// 7. Load an existing analysis back into UI (cached only)
// ----------------------------------------------------
async function loadAnalysis(id) {
  try {
    const res = await fetch(`${API_BASE}/api/analysis-snapshot?analysis_id=${encodeURIComponent(id)}`, {
      credentials: "include"
    });

    if (!res.ok) {
      showToast("Could not load analysis.", 'error');
      return;
    }

    const data = await res.json();
    analysisId = data.analysis_id;
    resultsContainer.innerHTML = "";

    // 1. Inject Verify All Bar
    if (data.claims.length > 1) {
         const allDone = data.claims.every(c => c.model_verdict && c.external_verdict);
         const btnClass = allDone ? "btn-success" : "btn-primary";
         const btnText = allDone ? `<i class="bi bi-check-all"></i> All Verified` : `<i class="bi bi-robot"></i> Verify All Claims`;
         const disabled = allDone ? "disabled" : "";

         resultsContainer.innerHTML = `
        <div class="verify-actions-bar sticky-top" style="top: 10px; z-index: 100;">
            <div><strong>${data.claims.length} Claims Loaded</strong></div>
            <button id="verify-all-btn" class="btn ${btnClass} btn-sm" onclick="runBatchVerification(${data.claims.length})" ${disabled}>
                ${btnText}
            </button>
        </div>`;
    }

    const wantPapers = document.getElementById("usePapersToggle")?.checked;

    data.claims.forEach((claim, idx) => {
      const claimId = `claim-${idx}`;
      
      // Determine existence of data
      const hasModel = !!claim.model_verdict;
      const hasExternal = !!claim.external_verdict;
      
      // Determine initial visual state based on current toggle
      const isVerified = wantPapers ? (hasModel && hasExternal) : hasModel;
      
      let buttonHtml = '';
      if (isVerified) {
          // ‚úÖ FIX: Added 'id="btn-verify-${idx}"' so the toggle script can find this button later
          buttonHtml = `<button id="btn-verify-${idx}" class="btn btn-sm btn-success disabled"><i class="bi bi-check-lg"></i> Verified</button>`;
      } else {
          buttonHtml = `<button id="btn-verify-${idx}" class="btn-verify-single" onclick="runSingleVerification(${idx})">Verify This Claim</button>`;
      }

      // --- Prepare Model Verdict HTML ---
      let modelVerdictHtml = '<span class="text-muted fst-italic">Waiting for verification...</span>';
      if (claim.model_verdict) {
          let badge = "";
          if (claim.used_model) {
              const clean = claim.used_model.replace(":free", "").replace("/", " / ");
              badge = `<span class="model-attribution-badge"><i class="bi bi-cpu"></i> Verified by ${escapeHTML(clean)}</span><br>`;
          }
          modelVerdictHtml = badge + formatTextWithMarkdownAndLinks(claim.model_verdict);
      }

      // --- Prepare External Verdict HTML ---
      let externalVerdictHtml = '<span class="text-muted fst-italic">Waiting for verification...</span>';
      if (claim.external_verdict) {
          let badge = "";
          if (claim.external_model) { 
              const clean = claim.external_model.replace(":free", "").replace("/", " / ");
              badge = `<span class="model-attribution-badge"><i class="bi bi-cpu"></i> Verified by ${escapeHTML(clean)}</span><br>`;
          }
          externalVerdictHtml = badge + formatTextWithMarkdownAndLinks(claim.external_verdict);
      }

      const claimHtml = `
        <div class="claim-card" id="${claimId}" 
             data-has-model="${hasModel}" 
             data-has-external="${hasExternal}">
             
          <div class="d-flex justify-content-between align-items-start">
            <h5>Claim ${idx + 1} ${getBadgeHtml('db')}</h5> 
            ${buttonHtml}
          </div>

          <p class="claim-text mb-3">${escapeHTML(claim.claim_text)}</p>

          <strong>Model Verdict:</strong>
          <div id="model-verdict-${claimId}" class="verdict-box model-verdict-box mb-3" style="min-height: 50px;">
            ${modelVerdictHtml}
          </div>

          <strong>Suggested Research Questions:</strong>
          <ul id="questions-list-${claimId}" class="question-list list-group list-group-flush mb-3">
            ${(claim.questions && claim.questions.length > 0) ? claim.questions.map((q, qIdx) => `
                <li class="list-group-item">
                    <span class="d-block mb-2"><b>Q${qIdx + 1}:</b> ${escapeHTML(q)}</span>
                    <button class="btn btn-primary btn-sm generate-report-btn"
                        data-claim-idx="${idx}"
                        data-question-idx="${qIdx}"
                        data-report-container-id="report-claim-${idx}-${qIdx}">
                    Generate Report
                    </button>
                    <div id="report-claim-${idx}-${qIdx}" class="report-placeholder mt-2 w-100"></div>
                </li>
            `).join('') : '<li class="list-group-item text-muted fst-italic">Generated after verification.</li>'}
          </ul>

          <hr>

          <strong>External Verification:</strong>
          <div id="external-verdict-${claimId}" class="verdict-box mb-2" style="min-height: 50px;">
            ${externalVerdictHtml}
          </div>
          <ul id="external-sources-${claimId}" class="source-list list-unstyled ps-3 mb-3">
             ${(claim.external_sources || []).map(s => `
                <li>üìÑ [${s.source || 'Ref'}] <a href="${s.url}" target="_blank" rel="noopener noreferrer">${escapeHTML(s.title || 'Source')}</a></li>
             `).join('')}
          </ul>
        </div>
      `;

      resultsContainer.innerHTML += claimHtml;
    });

    // Sync state immediately
    updateAllClaimButtons();

  } catch (err) {
    console.error("Error loading analysis:", err);
    showToast("Error loading analysis: " + err.message, 'error');
  }
}
  
window.loadAnalysis = loadAnalysis;
window.deleteAnalysis = deleteAnalysis;

document.getElementById("openHistoryBtn").onclick = async () => {
    await loadHistory();
    const modal = new bootstrap.Modal(document.getElementById("historyModal"));
    modal.show();
};



function b64ToBlob(b64, mime) {
    const byteChars = atob(b64);
    const byteNums = new Array(byteChars.length);
    for (let i = 0; i < byteChars.length; i++) byteNums[i] = byteChars.charCodeAt(i);
    const byteArray = new Uint8Array(byteNums);
    return new Blob([byteArray], { type: mime });
}
  
// Track all reports that the user generated (from cache or new) in this session
const reportSessionMap = new Map();

function sessionKey(c, q) { 
  return `${c}-${q}`; 
}

// ‚úÖ Register a report as ‚Äúgenerated‚Äù this session
function markReportGenerated(claimIdx, questionIdx) {
  const claimTextEl = document.querySelector(`#claim-${claimIdx} .claim-text`);
  const claimText = claimTextEl ? claimTextEl.textContent : `Claim ${claimIdx + 1}`;

  // Extract question text (for modal display)
  const qLi = document.querySelector(`#report-claim-${claimIdx}-${questionIdx}`)?.closest('li');
  const qSpan = qLi ? qLi.querySelector('span') : null;
  const questionTextRaw = qSpan ? qSpan.textContent : `Question ${questionIdx + 1}`;
  const questionText = questionTextRaw.replace(/^Q\d+:\s*/i, '').trim();

  reportSessionMap.set(sessionKey(claimIdx, questionIdx), {
    claimIdx,
    questionIdx,
    claimText,
    questionText
  });
}
  
function toggleLoading(button, isLoading, loadingText = '', progress = '') {
  // 1. Store the original HTML content (icon + text) on the first call
  if (!button.dataset.originalHtml) {
    button.dataset.originalHtml = button.innerHTML;
  }

  if (isLoading) {
    button.disabled = true;
    
    const progressStr = progress ? ` <span class="fw-normal opacity-75">(${progress})</span>` : '';
    
    // 2. Rebuild the button content cleanly
    // We force the spinner to be visible (d-inline-block) and append the new text
    button.innerHTML = `
      <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
      ${loadingText}${progressStr}
    `;
    
  } else {
    button.disabled = false;
    // 3. Restore the exact original HTML (hiding spinner, restoring original text)
    button.innerHTML = button.dataset.originalHtml;
  }
}

function escapeHTML(str) {
if (typeof str !== 'string') return str;
return str.replace(/[&<>"']/g, function(match) {
return {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
"'": '&#39;'
}[match];
});
}

// 1. Robust Table Parser (Replaces your Regex version)
function convertMarkdownTablesToHTML(text) {
    if (!text) return "";
    
    const lines = text.split('\n');
    let inTable = false;
    let htmlOut = [];
    let headerBuffer = null;

    // Helper to split rows cleanly (handles missing outer pipes)
    const parseTableLine = (line) => {
        let content = line.trim();
        if (content.startsWith('|')) content = content.substring(1);
        if (content.endsWith('|')) content = content.substring(0, content.length - 1);
        return content.split('|').map(c => c.trim());
    };

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // Detect separator line (e.g., |---| or |:---| or ---|---)
        // We remove pipes, dashes, colons and spaces. If nothing is left, it's a separator.
        const isSeparator = line.length > 0 && line.replace(/[| \-:]/g, '') === '' && line.includes('-');

        if (isSeparator && headerBuffer) {
            // FOUND A TABLE START!
            inTable = true;
            
            // 1. Start Table Wrapper (Bootstrap responsive)
            htmlOut.push('<div class="table-responsive mb-3"><table class="table table-bordered table-sm table-hover table-striped">');
            
            // 2. Process the buffered header
            const headerCells = parseTableLine(headerBuffer);
            htmlOut.push('<thead class="table-light"><tr>');
            headerCells.forEach(cell => htmlOut.push(`<th>${cell}</th>`));
            htmlOut.push('</tr></thead><tbody>');
            
            headerBuffer = null; // Clear buffer
            continue; // Skip the separator line itself
        }

        if (inTable) {
            // We are inside a table. 
            if (!line.includes('|')) {
                // End of table detected
                inTable = false;
                htmlOut.push('</tbody></table></div>');
                htmlOut.push(line); // Print the current non-table line
            } else {
                // It's a data row
                const cells = parseTableLine(line);
                htmlOut.push('<tr>');
                cells.forEach(cell => htmlOut.push(`<td>${cell}</td>`));
                htmlOut.push('</tr>');
            }
        } else {
            // We are NOT in a table.
            // If we have a buffer from the previous loop, it turned out NOT to be a header. Flush it.
            if (headerBuffer) {
                htmlOut.push(headerBuffer);
                headerBuffer = null;
            }

            // Does this line LOOK like a potential header? (Has pipes)
            if (line.includes('|')) {
                headerBuffer = line; // Store it, wait for next line to confirm (separator)
            } else {
                htmlOut.push(line);
            }
        }
    }

    // Cleanup: Close table if text ended inside one
    if (inTable) htmlOut.push('</tbody></table></div>');
    // Cleanup: Flush hanging header buffer
    if (headerBuffer) htmlOut.push(headerBuffer);

    return htmlOut.join('\n');
}

function formatTextWithMarkdownAndLinks(text) {
    if (!text) return "";

    // 1. Aggressive Normalization (Fixes encoding artifacts)
    let normalizedText = text.normalize('NFKD');
    
    // Map common encoding garbage to clean characters
    const charMap = {
        '√¢\u0080\u0093': '-', // En dash
        '√¢\u0080\u0094': '-', // Em dash
        '√¢\u0080\u0099': "'", // Smart quote
        '√¢\u0080\u009c': '"', // Left quote
        '√¢\u0080\u009d': '"', // Right quote
        '√¢\u0080\u00af': ' ', // Non-breaking space
        '√Ç': '',             // Random A hat
        '√¢': '-',            // Often replaces bullets
        '‚Äì': '-',
        '‚Äî': '-'
    };
    
    for (const [bad, good] of Object.entries(charMap)) {
        normalizedText = normalizedText.split(bad).join(good);
    }
    
    let formattedText = escapeHTML(normalizedText);

    // Fix Glued Verdicts
    formattedText = formattedText.replace(/([a-z])(AI's Initial Verdict:)/g, '$1<br><br><strong>$2</strong>');
    formattedText = formattedText.replace(/([a-z])(External Verification Verdict:)/g, '$1<br><br><strong>$2</strong>');

    // 2. Convert Tables to HTML
    formattedText = convertMarkdownTablesToHTML(formattedText);

    // 3. Process Line-by-Line
    const lines = formattedText.split('\n');
    let inHtmlBlock = false;
    
    const finalLines = lines.map(line => {
        let trimmed = line.trim();
        
        // A. HTML Table Protection
        if (trimmed.startsWith('<div class="table-responsive')) inHtmlBlock = true;
        if (inHtmlBlock) {
            if (trimmed.includes('</table></div>')) inHtmlBlock = false;
            return line; 
        }

        // B. Format Normal Text
        
        // ‚úÖ Smaller Headers (h6 + uppercase)
        const headerMatch = trimmed.match(/^(?:##\s*|)(\d+\.\s+)?\*\*(.*?)\*\*$/);
        if (headerMatch) {
            const numbering = headerMatch[1] || ""; 
            const content = headerMatch[2];       
            return `<h6 class="mt-4 mb-2 text-primary fw-bold text-uppercase" style="font-size: 0.9rem; letter-spacing: 0.5px;">${numbering}${content}</h6>`;
        }
        
        if (trimmed.startsWith('##')) {
            const headerContent = trimmed.replace(/^#+\s*/, '');
            return `<h6 class="mt-4 mb-2 text-primary fw-bold text-uppercase" style="font-size: 0.9rem; letter-spacing: 0.5px;">${headerContent}</h6>`;
        }
        
        // Bold
        line = line.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Links
        line = line.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
        line = line.replace(/(https?:\/\/[^\s<"']+)/g, (match) => {
            if (match.includes('</a>') || match.includes('">')) return match; 
            return `<a href="${match}" target="_blank" rel="noopener noreferrer">${match}</a>`;
        });

        // Bullets
        if (trimmed.startsWith('- ') || trimmed.startsWith('‚Ä¢ ')) {
            return `<li class="ms-3">${line.substring(2)}</li>`;
        }

        // Standard Newlines
        if (trimmed === '') return '<br>';
        return line + '<br>';
    });

    return finalLines.join('');
}
  
function setupFileUploadDragAndDrop(uploadArea, fileInput, onFileSelect) {
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
uploadArea.addEventListener(eventName, preventDefaults, false);
document.body.addEventListener(eventName, preventDefaults, false);
});
['dragenter', 'dragover'].forEach(eventName => {
uploadArea.addEventListener(eventName, highlight, false);
});
['dragleave', 'drop'].forEach(eventName => {
uploadArea.addEventListener(eventName, unhighlight, false);
});
uploadArea.addEventListener('drop', handleDrop, false);

function preventDefaults(e) {
e.preventDefault();
e.stopPropagation();
}

function highlight() {
uploadArea.classList.add('dragover');
}

function unhighlight() {
uploadArea.classList.remove('dragover');
}

function handleDrop(e) {
const dt = e.dataTransfer;
const files = dt.files;
fileInput.files = files;
onFileSelect(files[0]);
}

fileInput.addEventListener('change', (e) => {
if (e.target.files.length > 0) {
onFileSelect(e.target.files[0]);
}
});
}

function handleImageSelect(file) {
if (file && file.type.startsWith('image/')) {
currentImageFile = file;
processImageBtn.disabled = false;
const reader = new FileReader();
reader.onload = (e) => {
imagePreview.innerHTML = `<img src="${e.target.result}" class="preview-image" alt="Image preview">`;
};
reader.readAsDataURL(file);
} else {
showToast('Please select a valid image file (JPG, PNG, GIF)', 'info');
currentImageFile = null;
processImageBtn.disabled = true;
imagePreview.innerHTML = '';
}
}

function handleVideoSelect(file) {
if (file && file.type.startsWith('video/')) {
currentVideoFile = file;
processVideoBtn.disabled = false;
} else {
showToast('Please select a valid video file (MP4, AVI, MOV)', 'info');
currentVideoFile = null;
processVideoBtn.disabled = true;
}
}

async function processImage() {
if (!currentImageFile) {
showToast('Please select an image first.', 'info'); // or 'error'
return;
}
toggleLoading(processImageBtn, true, 'Processing image...');
const formData = new FormData();
formData.append('image', currentImageFile);
try {
const response = await fetch(`${API_BASE}/api/process-image`, {
method: 'POST',
body: formData
});
const data = await response.json();
if (!response.ok) {
throw new Error(data.error || 'Failed to process image');
}
textInput.value = data.extracted_text;
inputMethodSelect.value = 'paste';
inputMethodSelect.dispatchEvent(new Event('change'));
showToast('Text successfully extracted from image! Ready for analysis.', 'success');
} catch (error) {
showToast(`Error processing image: ${error.message}`, 'error');
} finally {
toggleLoading(processImageBtn, false);
}
}

// ‚úÖ Chrome AI transcription helper
async function transcribeWithChromeAI(audioBlob) {
  const hasPrompt = !!(window.ai && typeof window.ai.prompt === "function");
  if (!hasPrompt) throw new Error("Chrome Prompt API not available.");

  const audioBuf = await new Response(audioBlob).arrayBuffer();

  const input = {
    messages: [{
      role: "user",
      content: [
        { type: "input_audio", data: audioBuf, mime_type: "audio/wav" },
        { type: "text", text: "Transcribe this audio clearly into English text." }
      ]
    }]
  };

  const result = await window.ai.prompt(input);
  const text = (result?.output_text ?? result?.text ?? result) || "";
  if (!text.trim()) throw new Error("Chrome AI returned empty transcript.");
  return text.trim();
}


// If fetch isn't globally bound (Safari/ESM edge case)
if (!globalThis.fetch) globalThis.fetch = fetch;

async function transcribeWithTransformersWASM(audioBlob) {
  if (!window.__tf_asr) {
    console.log("Initializing Whisper...");
    window.__tf_asr = await window.__tf.pipeline(
      "automatic-speech-recognition",
      "Xenova/whisper-tiny.en"
    );
  }

  const arrayBuffer = await audioBlob.arrayBuffer();

  // ‚úÖ Force AudioContext to NOT upsample
  // Safari/Chrome will default to 48k, so we override
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)({
    sampleRate: 16000
  });

  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

  // ‚úÖ Manually downsample to 16k buffer Whisper expects
  const input = audioBuffer.getChannelData(0);
  const sr = audioBuffer.sampleRate;

  if (sr !== 16000) {
    console.warn(`Browser decoded at ${sr}Hz, resampling to 16k...`);

    const ratio = sr / 16000;
    const resampled = new Float32Array(Math.round(input.length / ratio));

    for (let i = 0; i < resampled.length; i++) {
      resampled[i] = input[Math.round(i * ratio)] || 0;
    }

    return runWhisper(resampled);
  }

  return runWhisper(input);

  async function runWhisper(float32Audio) {
    console.log("Transcribing via Whisper WASM‚Ä¶");

    const output = await window.__tf_asr(float32Audio, {
      chunk_length_s: 30,
      stride_length_s: 5,
      language: "en"
    });

    const text = output.text?.trim();
    if (!text) throw new Error("Empty transcript");

    return text;
  }
}

  
// ‚úÖ Main video handler (fixed)
async function processVideo() {
  const file = document.getElementById('videoInput').files[0];
  if (!file) return;

  const btn = document.getElementById('process-video-btn');
  toggleLoading(btn, true, 'Extracting audio...');

  const formData = new FormData();
  formData.append('file', file);

  try {
    // 1. Extract audio ‚Üí get 16kHz WAV blob
    const response = await fetch(`${API_BASE}/api/extract-audio`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const err = await response.text();
      throw new Error(err || 'Audio extraction failed');
    }

    const audioBlob = await response.blob();
    if (audioBlob.size === 0) throw new Error("Empty audio file");

    // 2. Transcribe locally
    toggleLoading(btn, true, 'Transcribing locally...');
    const transcript = await transcribeWithTransformersWASM(audioBlob);

    // 3. Success
    document.getElementById('textInput').value = transcript;
    inputMethodSelect.value = 'paste';
    inputMethodSelect.dispatchEvent(new Event('change'));

    showToast('Transcription complete!', 'success');

  } catch (err) {
    console.error("Transcription failed:", err);
    showToast('Error: ' + err.message, 'error');
  } finally {
    toggleLoading(btn, false);
  }
}
  
async function transcribeVideoUrl() {
  const urlInput = document.getElementById("videoUrlInput");
  const btn = document.getElementById("transcribe-video-url-btn");
  const url = urlInput.value.trim();

  if (!url) return showToast("Enter a YouTube URL", 'info');

  // 1. Extract Video ID
  // Handles: youtube.com/watch?v=ID, youtu.be/ID, youtube.com/embed/ID
  const ytMatch = url.match(/(?:youtu\.be\/|v=|\/embed\/)([\w-]+)/);
  if (!ytMatch) {
    return showToast("Invalid YouTube URL. Please use a standard link.", 'info');
  }
  const videoId = ytMatch[1];

  toggleLoading(btn, true, "Hunting for captions...");
  urlInput.disabled = true;

  let fullText = "";
  let usedSource = "";

  try {
    // =================================================================
    // ATTEMPT 1: 3rd Party Scraper via 'AllOrigins' Proxy
    // AllOrigins is often less blocked than other proxies
    // =================================================================
    try {
        console.log("Attempt 1: youtubetranscript.com via AllOrigins");
        const targetUrl = `https://youtubetranscript.com/Transcript?n=${videoId}`;
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`;
        
        const res = await fetch(proxyUrl);
        if (res.ok) {
            const xml = await res.text();
            if (xml.includes("<text")) {
                fullText = parseXmlTranscript(xml);
                if (fullText) usedSource = "Scraper (AllOrigins)";
            }
        }
    } catch (e) { console.warn("Attempt 1 failed:", e); }

    // =================================================================
    // ATTEMPT 2: 3rd Party Scraper via 'CorsProxy'
    // Fallback proxy if AllOrigins fails/timeouts
    // =================================================================
    if (!fullText) {
        try {
            console.log("Attempt 2: youtubetranscript.com via CorsProxy");
            const targetUrl = `https://youtubetranscript.com/Transcript?n=${videoId}`;
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
            
            const res = await fetch(proxyUrl);
            if (res.ok) {
                const xml = await res.text();
                if (xml.includes("<text")) {
                    fullText = parseXmlTranscript(xml);
                    if (fullText) usedSource = "Scraper (CorsProxy)";
                }
            }
        } catch (e) { console.warn("Attempt 2 failed:", e); }
    }

    // =================================================================
    // ATTEMPT 3: Piped API Network (Decentralized YouTube Backends)
    // If scraper sites are down, these instances talk to YT directly.
    // =================================================================
    if (!fullText) {
        console.log("Attempt 3: Piped API Network");
        const pipedInstances = [
            "https://api.piped.pw",           // Usually most reliable
            "https://pipedapi.kavin.rocks",   // Popular, sometimes rate limited
            "https://pipedapi.drgns.space",
            "https://api.piped.gl",
            "https://pa.il.ax"
        ];

        for (const base of pipedInstances) {
            try {
                console.log(`Trying Piped instance: ${base}`);
                // 2 second timeout to fail fast if instance is lagging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);
                
                const res = await fetch(`${base}/streams/${videoId}`, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!res.ok) continue;

                const data = await res.json();
                if (!data.subtitles || data.subtitles.length === 0) continue;

                // Find English (Manual > Auto)
                // Check 'code' (en) or 'name' (English)
                let track = data.subtitles.find(s => s.code === 'en' && !s.autoGenerated);
                if (!track) track = data.subtitles.find(s => s.code === 'en');
                if (!track) track = data.subtitles.find(s => s.name && s.name.includes('English'));

                if (track) {
                    const subRes = await fetch(track.url);
                    if (subRes.ok) {
                        const vtt = await subRes.text();
                        fullText = parseVttTranscript(vtt);
                        if (fullText) {
                            usedSource = `Piped API (${base})`;
                            break; // Exit loop
                        }
                    }
                }
            } catch (e) { console.warn(`Skipping ${base}:`, e.message); }
        }
    }

    // =================================================================
    // FINALIZE
    // =================================================================
    if (!fullText || fullText.length < 20) {
        throw new Error("Exhausted all sources. Video may lack English captions or is geo-locked.");
    }

    console.log(`‚úÖ Success via ${usedSource}`);

    // Fill Input
    const textInput = document.getElementById("textInput");
    const inputMethodSelect = document.getElementById("inputMethod");
    
    textInput.value = fullText;
    inputMethodSelect.value = "paste";
    inputMethodSelect.dispatchEvent(new Event("change"));

    // Trigger Chrome AI if enabled
    const chromeToggle = document.getElementById("enableChromeAiToggle");
    if (chromeToggle && chromeToggle.checked) {
         const chromeBtn = document.querySelector("#chrome-ai-text button");
         if(chromeBtn) {
             chromeBtn.innerHTML = "ü§ñ Auto-cleaning transcript...";
             setTimeout(() => chromeBtn.click(), 500);
         }
    } else {
         showToast("‚úÖ Transcript imported!", 'success');
    }

  } catch (err) {
    console.error(err);
    showToast("Unable to fetch captions.\n\nTechnical reason: YouTube is blocking scraping requests from this browser/network.\n\nWorkaround: Please open the video description on YouTube, click 'Show Transcript', copy the text, and paste it here.", 'info');
  } finally {
    toggleLoading(btn, false);
    urlInput.disabled = false;
  }
}

// --- HELPER PARSERS ---

function parseXmlTranscript(xml) {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xml, "text/xml");
        const textNodes = xmlDoc.getElementsByTagName("text");
        let extracted = [];
        for (let i = 0; i < textNodes.length; i++) {
            // Decode HTML entities automatically via textContent
            extracted.push(textNodes[i].textContent);
        }
        return extracted.join(" ").replace(/\s+/g, " ").trim();
    } catch (e) { return null; }
}

function parseVttTranscript(vtt) {
    try {
        return vtt
            .replace(/WEBVTT/g, "")
            .replace(/(\d{2}:)?\d{2}:\d{2}\.\d{3} --> (\d{2}:)?\d{2}:\d{2}\.\d{3}/g, "")
            .replace(/<[^>]+>/g, "")
            .replace(/align:[^\s]+/g, "")
            .replace(/position:[^\s]+/g, "")
            .replace(/line:[^\s]+/g, "")
            .replace(/^\s*[\r\n]/gm, "")
            .replace(/\n+/g, " ")
            .trim();
    } catch (e) { return null; }
}

// (Keep your toggleLoading helper as is)
function toggleLoading(btn, isLoading, msg = "") {
  const spinner = btn.querySelector(".spinner-border");
  if (isLoading) {
    btn.disabled = true;
    if(spinner) spinner.classList.remove("d-none");
    if (!btn.dataset.originalText) btn.dataset.originalText = btn.lastChild.textContent;
    btn.lastChild.textContent = " " + msg;
  } else {
    btn.disabled = false;
    if(spinner) spinner.classList.add("d-none");
    if (btn.dataset.originalText) btn.lastChild.textContent = btn.dataset.originalText;
  }
}

// ‚úÖ NEW: Updates button states based on Toggle + Data Attributes
function updateAllClaimButtons() {
    const wantPapers = document.getElementById("usePapersToggle").checked;
    const cards = document.querySelectorAll('.claim-card');
    let allVerified = true;

    cards.forEach((card, index) => {
        const btn = document.getElementById(`btn-verify-${index}`);
        if (!btn) return; 

        // Read state from DOM
        const hasModel = card.getAttribute('data-has-model') === 'true';
        const hasExternal = card.getAttribute('data-has-external') === 'true';

        // Logic: Verified if Model exists AND (External exists OR we don't want external)
        const isVerified = hasModel && (hasExternal || !wantPapers);

        if (isVerified) {
            btn.innerHTML = `<i class="bi bi-check-lg"></i> Verified`;
            btn.className = "btn btn-success btn-sm disabled"; // Visual consistency
            // We don't set btn.disabled = true here to allow manual re-clicks if needed, 
            // but the class makes it look done.
        } else {
            // Revert to Blue
            btn.innerHTML = `Verify This Claim`;
            btn.className = "btn-verify-single";
            btn.disabled = false;
            allVerified = false;
        }
    });

    // Update "Verify All" Button State
    const batchBtn = document.getElementById('verify-all-btn');
    if (batchBtn && !batchBtn.disabled) { // Don't change text if currently processing
        if (allVerified && cards.length > 0) {
            batchBtn.innerHTML = `<i class="bi bi-check-all"></i> All Verified`;
            batchBtn.className = "btn btn-success btn-sm";
        } else {
            batchBtn.innerHTML = `<i class="bi bi-robot"></i> Verify All Claims`;
            batchBtn.className = "btn btn-primary btn-sm";
        }
    }
}

// ‚úÖ ADD LISTENER: Run update when toggle changes
document.addEventListener('DOMContentLoaded', () => {
    const toggle = document.getElementById("usePapersToggle");
    if(toggle) toggle.addEventListener('change', updateAllClaimButtons);
});
  
function displayClaimsStructure(claims, isCached = false) {
    const badgeHtml = isCached ? getBadgeHtml('db') : '';
    
    let controlBar = '';
    if (claims.length > 1) {
        controlBar = `
        <div class="verify-actions-bar sticky-top" style="top: 10px; z-index: 100;">
            <div><strong>${claims.length} Claims Extracted</strong></div>
            <button id="verify-all-btn" class="btn btn-primary btn-sm" onclick="runBatchVerification(${claims.length})">
                <i class="bi bi-robot"></i> Verify All Claims
            </button>
        </div>`;
    }

    resultsContainer.innerHTML = controlBar;

    claims.forEach((claimText, index) => {
        const claimId = `claim-${index}`;
        
        // ‚úÖ FIX: Add data attributes initialized to false (since this is a fresh run)
        const claimHtml = `
        <div class="claim-card" id="${claimId}" data-has-model="false" data-has-external="false">
            <div class="d-flex justify-content-between align-items-start">
                <h5>Claim ${index + 1} ${badgeHtml}</h5>
                <button id="btn-verify-${index}" class="btn-verify-single" onclick="runSingleVerification(${index})">
                    Verify This Claim
                </button>
            </div>
            
            <p class="claim-text mb-3">${escapeHTML(claimText)}</p>
            
            <!-- MODEL VERDICT -->
            <strong>Model Verdict:</strong>
            <div id="model-verdict-${claimId}" class="verdict-box model-verdict-box mb-3" style="min-height: 50px;">
                <span class="text-muted fst-italic">Waiting for verification...</span>
            </div>
            
            <!-- QUESTIONS -->
            <strong>Suggested Research Questions:</strong>
            <ul id="questions-list-${claimId}" class="question-list list-group list-group-flush mb-3">
                 <li class="list-group-item text-muted fst-italic">Generated after verification.</li>
            </ul>
            
            <hr>
            
            <!-- EXTERNAL -->
            <strong>External Verification (Semantic Scholar, CORE, Crossref & PubMed):</strong>
            <div id="external-verdict-${claimId}" class="verdict-box mb-2" style="min-height: 50px;">
                <span class="text-muted fst-italic">Waiting for verification...</span>
            </div>
            <ul id="external-sources-${claimId}" class="source-list list-unstyled ps-3 mb-3"></ul>
        </div>
        `;
        resultsContainer.innerHTML += claimHtml;
    });

    toggleLoading(runAnalysisBtn, false);
}

async function runSingleVerification(index) {
    if (activeVerifications.has(index)) return;
    const btn = document.getElementById(`btn-verify-${index}`);
    if (!btn) return;

    activeVerifications.add(index);
    
    // UI Loading
    btn.disabled = true;
    btn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Verifying...`;

    const verdictId = `model-verdict-claim-${index}`;
    const questionsId = `questions-list-claim-${index}`;
    const extVerdictId = `external-verdict-claim-${index}`;
    const extSourcesId = `external-sources-claim-${index}`;
    
    const preferredModel = document.getElementById("preferredModel")?.value || null;
    const usePapers = document.getElementById("usePapersToggle")?.checked;
    const card = document.getElementById(`claim-${index}`);

    try {
        // 1. AI Verification
        await getModelDetails(index, verdictId, questionsId, null, true, preferredModel);
        
        // ‚úÖ Update State
        card.setAttribute('data-has-model', 'true');

        // 2. External Verification
        if (usePapers) {
            await verifyExternal(index, extVerdictId, extSourcesId, null, true, preferredModel);
            // ‚úÖ Update State
            card.setAttribute('data-has-external', 'true');
        } else {
            const extContainer = document.getElementById(extVerdictId);
            if(extContainer) extContainer.innerHTML = '<span class="text-muted">External verification disabled.</span>';
        }

        // ‚úÖ Final UI Refresh: This decides if the button turns Green or stays Blue
        updateAllClaimButtons();
        
    } catch (error) {
        console.error(error);
        btn.innerHTML = `Retry Verification`;
        btn.className = "btn-verify-single"; // Ensure it looks clickable
        btn.disabled = false; 
        showToast(`Verification failed for Claim ${index + 1}`, 'error');
    } finally {
        activeVerifications.delete(index);
    }
}

async function runBatchVerification(totalClaims) {
    const batchBtn = document.getElementById('verify-all-btn');
    if (!batchBtn) return;

    // Ensure button states are fresh before starting
    updateAllClaimButtons();

    batchBtn.disabled = true;
    batchBtn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Processing...`;

    let processedCount = 0;

    for (let i = 0; i < totalClaims; i++) {
        const singleBtn = document.getElementById(`btn-verify-${i}`);
        
        // ‚úÖ Logic: If button is Green (btn-success), it means it satisfies the CURRENT toggle state.
        // So we skip it. If it's Blue, we click it.
        if (!singleBtn || singleBtn.classList.contains('btn-success')) {
            processedCount++;
            continue; 
        }

        // Update Batch Progress
        batchBtn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Verifying ${i + 1}/${totalClaims}...`;

        const card = document.getElementById(`claim-${i}`);
        if(card) card.scrollIntoView({ behavior: 'smooth', block: 'center' });

        await runSingleVerification(i);
        await new Promise(r => setTimeout(r, 500));
        processedCount++;
    }

    // Final State Check
    updateAllClaimButtons();
}

// Attach to window so HTML can see them
window.runSingleVerification = runSingleVerification;
window.runBatchVerification = runBatchVerification;
  
// ‚úÖ Added 'preferredModel' parameter (defaults to null)
async function getModelDetails(claimIdx, verdictContainerId, questionsContainerId, button, autoLoad = false, preferredModel = null) {
  const verdictContainer = document.getElementById(verdictContainerId);
  const questionsList = document.getElementById(questionsContainerId);

  if (!autoLoad && button) toggleLoading(button, true, "Loading details...");

  try {
    const response = await fetch(`${API_BASE}/api/get-claim-details`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        analysis_id: analysisId,
        claim_idx: claimIdx,
        preferred_model: preferredModel
      })
    });

    const data = await response.json();

    // Check for Logic Errors
    if (data.model_verdict && (
        data.model_verdict.startsWith("Error:") || 
        data.model_verdict.includes("System Busy") ||
        data.model_verdict.includes("Rate Limit")
    )) {
        throw new Error(data.model_verdict); 
    }

    // ‚úÖ FIX: Use new mobile-friendly badge class
    const modelName = data.used_model || "Unknown Model";
    const displayModel = modelName.replace(":free", "").replace("/", " / ");
    const modelBadge = `<span class="model-attribution-badge"><i class="bi bi-cpu"></i> Verified by ${escapeHTML(displayModel)}</span><br>`;

    const formattedVerdict = formatTextWithMarkdownAndLinks(data.model_verdict);
    verdictContainer.innerHTML = modelBadge + formattedVerdict;

    // ... (Questions logic remains exactly the same) ...
    questionsList.innerHTML = '';
    if (data.questions && data.questions.length > 0) {
      data.questions.forEach((q, q_idx) => {
        const listItem = document.createElement('li');
        listItem.className = 'list-group-item';
        listItem.innerHTML = `
          <span class="d-block mb-2"><b>Q${q_idx + 1}:</b> ${escapeHTML(q)}</span>
          <button class="btn btn-primary btn-sm generate-report-btn"
            data-claim-idx="${claimIdx}"
            data-question-idx="${q_idx}"
            data-report-container-id="report-claim-${claimIdx}-${q_idx}">
            Generate Report
          </button>
          <div id="report-claim-${claimIdx}-${q_idx}" class="report-placeholder mt-2 w-100"></div>
        `;
        questionsList.appendChild(listItem);
        
        const reportId = `claim-${claimIdx}-question-${q_idx}`;
        if (!generatedReports.find(r => r.id === reportId)) {
          generatedReports.push({
            id: reportId,
            claimIdx: claimIdx,
            questionIdx: q_idx,
            claimText: document.querySelector(`#claim-${claimIdx} .claim-text`).textContent,
            questionText: q
          });
        }
      });
    } else {
      questionsList.innerHTML = '<li class="list-group-item">No research questions generated.</li>';
    }
  } catch (error) {
    verdictContainer.innerHTML = `<div class="alert alert-danger p-2 mt-2">Error: ${escapeHTML(error.message)}</div>`;
    questionsList.innerHTML = `<li class="list-group-item text-danger">Could not load questions: ${escapeHTML(error.message)}</li>`;
    // Re-throw so runSingleVerification knows it failed
    throw error; 
  } finally {
    if (!autoLoad && button) toggleLoading(button, false);
  }
}
  
  
async function fetchCorePapers(claimText) {
    // 1. Improved Keyword Extraction
    // Remove punctuation, split by space
    const cleanText = claimText.replace(/[^\w\s]/g, '');
    const words = cleanText.split(/\s+/);
    
    // Filter: 4+ chars, ignore common stop words
    const keywords = words.filter(w => w.length >= 4 && !["that", "this", "with", "from", "have", "were", "what"].includes(w.toLowerCase()));
    
    // Take top 6 keywords to broaden search
    const query = keywords.slice(0, 6).join(" "); 
    
    console.log("üîç CORE Debug - Query:", query);

    if (!query) {
        console.warn("üîç CORE Debug - Query empty");
        return [];
    }

    try {
        const response = await fetch('/api/core-proxy', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            // üü¢ FIX: Send key 'query' to match backend expectation (not 'q')
            body: JSON.stringify({ query: query }) 
        });

        if (!response.ok) {
            console.error("üîç CORE Debug - Proxy Error:", response.status, await response.text());
            return [];
        }

        const data = await response.json();
        console.log("üîç CORE Debug - Raw Results:", data);

        if (!data.results || data.results.length === 0) {
            console.warn("üîç CORE Debug - No results found for query.");
            return [];
        }
        
        // Map to Epistemiq format
        const mapped = data.results.map(item => ({
            title: item.title,
            // Fallback for abstract
            abstract: item.abstract || item.description || "Abstract not available from CORE.",
            url: item.downloadUrl || (item.links && item.links[0] ? item.links[0].url : `https://core.ac.uk/outputs/${item.id}`),
            authors: (item.authors || []).map(a => a.name).join(", "),
            // Ensure year is string
            year: item.yearPublished ? String(item.yearPublished) : "", 
            source: "CORE", 
            citation_count: item.citationCount || 0
        }));

        console.log("üîç CORE Debug - Mapped:", mapped);
        return mapped;

    } catch (e) {
        console.error("üîç CORE Debug - Fetch Failed:", e);
        return [];
    }
}
  
async function verifyExternal(claimIdx, verdictContainerId, sourcesContainerId, button, autoLoad = false, preferredModel = null) {
    const verdictContainer = document.getElementById(verdictContainerId);
    const sourcesContainer = document.getElementById(sourcesContainerId);
    
    if (!preferredModel) {
        const selector = document.getElementById("preferredModel");
        if (selector) preferredModel = selector.value;
    }

    const claimText = document.querySelector(`#claim-${claimIdx} .claim-text`)?.innerText || "";

    if (!autoLoad && button) toggleLoading(button, true, "Verifying...");
    
    if (!autoLoad) {
        verdictContainer.innerHTML = '<span class="text-muted">Verifying...</span>';
        sourcesContainer.innerHTML = '';
    }

    try {
        const coreSources = await fetchCorePapers(claimText);
        
        const response = await fetch(`${API_BASE}/api/verify-external`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                analysis_id: analysisId,
                claim_idx: claimIdx,
                client_sources: coreSources,
                preferred_model: preferredModel 
            })
        });

        const data = await response.json();
        
        // Check for Logic Errors
        if (data.verdict && (
            data.verdict.startsWith("Error:") || 
            data.verdict.includes("System Busy") ||
            data.verdict.includes("Rate Limit")
        )) {
            throw new Error(data.verdict); 
        }
        
        if (!response.ok) {
            throw new Error(data.error || `External verification failed: ${response.status}`);
        }

        let verdictHtml = formatTextWithMarkdownAndLinks(data.verdict);
        
        // ‚úÖ FIX: Use new mobile-friendly badge class
        if (data.used_model) {
            const cleanModel = data.used_model.replace(":free", "").replace("/", " / ");
            const badge = `<span class="model-attribution-badge"><i class="bi bi-cpu"></i> Verified by ${escapeHTML(cleanModel)}</span><br>`;
            verdictHtml = badge + verdictHtml;
        }
        
        verdictContainer.innerHTML = verdictHtml;

        if (data.sources && data.sources.length > 0) {
            sourcesContainer.innerHTML = data.sources.map(s => {
                const sourceInfo = s.source ? `[${s.source}]` : '';
                const citationInfo = s.citation_count ? ` (${s.citation_count} citations)` : '';
                const yearInfo = s.year ? ` (${s.year})` : '';
                const authorsInfo = s.authors ? ` - ${s.authors}` : '';
                
                return `<li>üìÑ ${sourceInfo} <a href="${s.url}" target="_blank" rel="noopener noreferrer">${escapeHTML(s.title)}</a>${authorsInfo}${yearInfo}${citationInfo}</li>`;
            }).join('');
        } else {
            sourcesContainer.innerHTML = `<li>No external sources found.</li>`;
        }
    } catch (error) {
        console.error(error);
        verdictContainer.innerHTML = `<div class="alert alert-warning p-2 mt-2">Error: ${escapeHTML(error.message)}</div>`;
        sourcesContainer.innerHTML = `<li>Could not fetch sources.</li>`;
        // Re-throw for button status
        throw error;
    } finally {
        if (!autoLoad && button) toggleLoading(button, false);
    }
}

  
function showReportInModal(reportContent, claimIdx, questionIdx) {
const modal = document.getElementById('researchReportModal');
const modalTitle = document.getElementById('researchReportModalLabel');
const modalContent = document.getElementById('modal-report-content');
modalTitle.textContent = `Research Report - Claim ${claimIdx + 1}, Question ${questionIdx + 1}`;
modalContent.innerHTML = formatTextWithMarkdownAndLinks(reportContent);
modal.style.display = 'block';
document.body.classList.add('body-no-scroll');
const copyButton = document.getElementById('copy-report-btn');
copyButton.onclick = () => {
navigator.clipboard.writeText(reportContent).then(() => {
const originalText = copyButton.innerHTML;
copyButton.innerHTML = '‚úì Copied!';
setTimeout(() => {
copyButton.innerHTML = originalText;
}, 2000);
}).catch(err => {
console.error('Failed to copy: ', err);
showToast('Failed to copy report to clipboard', 'error');
});
};
}

async function generateReport(claimIdx, questionIdx, reportContainerId, button) {
  const reportContainer = document.getElementById(reportContainerId);
  const preferredModel = document.getElementById("preferredModel")?.value || "";

  reportContainer.innerHTML =
    '<div class="report-box text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div> Generating report...</div>';
  
  if (button) { 
      button.disabled = true; 
      button.innerHTML = 'Generating...'; 
  }

  try {
    const es = new EventSource(
      `${API_BASE}/api/generate-report?analysis_id=${encodeURIComponent(analysisId)}&claim_idx=${encodeURIComponent(claimIdx)}&question_idx=${encodeURIComponent(questionIdx)}&preferred_model=${encodeURIComponent(preferredModel)}`,
      { withCredentials: true }
    );

    let fullContent = '';
    let isFirstChunk = true;
    let reportBox = null;
    let detectedModel = null;

    es.onmessage = (event) => {
      if (event.data === '[DONE]') {
        es.close();
        if (button) { 
            button.disabled = false; 
            button.innerHTML = 'Generate Report'; 
        }

        if (fullContent && fullContent.trim().length > 0) {
          let finalHtml = formatTextWithMarkdownAndLinks(fullContent);
          if (detectedModel) {
              const cleanModel = detectedModel.replace(":free", "").replace("/", " / ");
              // ‚úÖ FIX: New badge
              const badge = `<span class="model-attribution-badge"><i class="bi bi-cpu"></i> Report by ${escapeHTML(cleanModel)}</span><br>`;
              finalHtml = badge + finalHtml;
          }
          if (reportBox) reportBox.innerHTML = finalHtml;

          const viewBtn = document.createElement('button');
          viewBtn.className = 'btn btn-outline-primary btn-sm mt-2';
          viewBtn.textContent = 'üìñ View Full Report';
          viewBtn.onclick = () => showReportInModal(fullContent, claimIdx, questionIdx);
          reportContainer.appendChild(viewBtn);

          markReportGenerated(claimIdx, questionIdx);
        } else {
          reportContainer.innerHTML = '<div class="alert alert-warning p-2">No report content returned.</div>';
        }
        return;
      }

      if (isFirstChunk) {
          reportContainer.innerHTML = '<div class="report-box compact-report"></div>';
          reportBox = reportContainer.querySelector('.report-box');
          isFirstChunk = false;
      }

      try {
        const data = JSON.parse(event.data);
        if (data.content) fullContent += data.content;
        if (data.used_model) detectedModel = data.used_model;

        if (data.error) {
          reportBox.innerHTML += `<br><strong class="text-danger">Error: ${escapeHTML(data.error)}</strong>`;
        } else {
            let currentHtml = formatTextWithMarkdownAndLinks(fullContent);
            if (detectedModel) {
                const cleanModel = detectedModel.replace(":free", "").replace("/", " / ");
                // ‚úÖ FIX: New badge
                const badge = `<span class="model-attribution-badge"><i class="bi bi-cpu"></i> Report by ${escapeHTML(cleanModel)}</span><br>`;
                currentHtml = badge + currentHtml;
            }
            reportBox.innerHTML = currentHtml;
        }
      } catch {
        fullContent += event.data;
        reportBox.innerHTML = formatTextWithMarkdownAndLinks(fullContent);
      }
    };

    es.onerror = () => {
      es.close();
      reportContainer.innerHTML = `<div class="alert alert-danger">Stream error or unsupported media type.</div>`;
      if (button) { 
          button.disabled = false; 
          button.innerHTML = 'Generate Report'; 
      }
    };
  } catch (error) {
    console.error('Report generation error:', error);
    reportContainer.innerHTML = `<div class="alert alert-danger">${escapeHTML(error.message)}</div>`;
    if (button) { 
        button.disabled = false; 
        button.innerHTML = 'Generate Report'; 
    }
  }
}


// NEW PDF DOWNLOAD FUNCTIONS

async function openReportSelectionModal() {
  try {
    if (!analysisId) {
      showToast('No analysis found. Please run an analysis first.', 'info');
      return;
    }

    toggleLoading(downloadPdfBtn, true, 'Loading available reports...');

    const resp = await fetch(`${API_BASE}/api/available-reports?analysis_id=${analysisId}`, {
      credentials: "include"
    });
    if (!resp.ok) throw new Error('Failed to load available reports');

    const available = await resp.json(); // [{ id, type, description }, ...]

    // Always include claim summaries (model + external)
    const summaries = available.filter(r => r.id && r.id.endsWith('-summary'));

    // Only include research reports generated this session
    const sessionKeys = Array.from(reportSessionMap.keys());
    const sessionReports = available.filter(r => {
      if (!r.id || !r.id.includes('question')) return false;
      const parts = r.id.split('-');
      if (parts.length !== 4) return false;
      const c = parseInt(parts[1], 10);
      const q = parseInt(parts[3], 10);
      if (Number.isNaN(c) || Number.isNaN(q)) return false;
      return sessionKeys.includes(`${c}-${q}`);
    });

    const listForModal = [...summaries, ...sessionReports];

    if (!listForModal || listForModal.length === 0) {
      showToast('No reports or claim summaries found for this analysis.', 'info');
      return;
    }

    populateReportSelectionModal(listForModal);

    const modal = new bootstrap.Modal(document.getElementById('reportSelectionModal'));
    modal.show();

  } catch (err) {
    console.error('Error opening report selection modal:', err);
    showToast(`Error: ${err.message}`, 'error');
  } finally {
    toggleLoading(downloadPdfBtn, false);
  }
}


  
  
function populateReportSelectionModal(availableReports) {
const selectionList = document.getElementById('report-selection-list');
if (!availableReports || availableReports.length === 0) {
selectionList.innerHTML = '<p class="text-muted">No reports available for download.</p>';
return;
}
let html = '';
availableReports.forEach((report, index) => {
html += `
<div class="report-selection-item">
<div class="form-check">
<input class="form-check-input report-selection-checkbox" type="checkbox"
id="modal-report-${index}" value="${report.id}" checked>
<label class="form-check-label" for="modal-report-${index}">
<strong>${report.type}</strong><br>
<small class="text-muted">${report.description}</small>
</label>
</div>
</div>
`;
});
selectionList.innerHTML = html;
setupSelectionModalEvents();
}

function setupSelectionModalEvents() {
const selectAllBtn = document.getElementById('select-all-reports-modal');
const deselectAllBtn = document.getElementById('deselect-all-reports-modal');
const generatePdfBtn = document.getElementById('generate-pdf-from-modal');
selectAllBtn.replaceWith(selectAllBtn.cloneNode(true));
deselectAllBtn.replaceWith(deselectAllBtn.cloneNode(true));
generatePdfBtn.replaceWith(generatePdfBtn.cloneNode(true));
const freshSelectAllBtn = document.getElementById('select-all-reports-modal');
const freshDeselectAllBtn = document.getElementById('deselect-all-reports-modal');
const freshGeneratePdfBtn = document.getElementById('generate-pdf-from-modal');
freshSelectAllBtn.addEventListener('click', () => {
document.querySelectorAll('.report-selection-checkbox').forEach(checkbox => {
checkbox.checked = true;
});
});
freshDeselectAllBtn.addEventListener('click', () => {
document.querySelectorAll('.report-selection-checkbox').forEach(checkbox => {
checkbox.checked = false;
});
});
freshGeneratePdfBtn.addEventListener('click', generatePdfFromSelections);
}

async function generatePdfFromSelections() {
  const generatePdfBtn = document.getElementById('generate-pdf-from-modal');
  const checkboxes = document.querySelectorAll('.report-selection-checkbox:checked');
  
  if (checkboxes.length === 0) {
    showToast('Please select at least one report to include in the PDF.', 'info');
    return;
  }

  // ‚úÖ SORTING FIX: Ensure backend receives claims in order (0, 1, 2...)
  // and summaries before questions.
  const selectedReportIds = Array.from(checkboxes)
    .map(cb => cb.value)
    .sort((a, b) => {
        // Parse "claim-X..."
        const claimA = parseInt(a.split('-')[1]);
        const claimB = parseInt(b.split('-')[1]);
        if (claimA !== claimB) return claimA - claimB;
        
        // If claims match, put summary first
        if (a.includes('summary')) return -1;
        if (b.includes('summary')) return 1;
        
        // If both questions, sort by question index
        const qA = parseInt(a.split('-')[3] || 0);
        const qB = parseInt(b.split('-')[3] || 0);
        return qA - qB;
    });

  try {
    toggleLoading(generatePdfBtn, true, 'Generating PDF...');
    const response = await fetch(`${API_BASE}/api/export-pdf`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        analysis_id: analysisId,
        selected_reports: selectedReportIds
      }),
      credentials: "include"
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(errorText || 'Failed to generate PDF');
    }

    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'Epistemiq_AI_Report.pdf';
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);

    const modal = bootstrap.Modal.getInstance(document.getElementById('reportSelectionModal'));
    modal.hide();
  } catch (error) {
    console.error('Error generating PDF:', error);
    showToast(`Error generating PDF: ${error.message}`, 'error');
  } finally {
    toggleLoading(generatePdfBtn, false);
  }
}


// Modal close functionality
const researchReportModal = document.getElementById('researchReportModal');
const closeButtons = researchReportModal.querySelectorAll('.custom-close-btn');
const overlay = document.getElementById('custom-modal-overlay');
closeButtons.forEach(btn => {
btn.addEventListener('click', () => {
researchReportModal.style.display = 'none';
document.body.classList.remove('body-no-scroll');
});
});
overlay.addEventListener('click', () => {
researchReportModal.style.display = 'none';
document.body.classList.remove('body-no-scroll');
});
document.addEventListener('keydown', (e) => {
if (e.key === 'Escape' && researchReportModal.style.display === 'block') {
researchReportModal.style.display = 'none';
document.body.classList.remove('body-no-scroll');
}
});

// Event Listeners
inputMethodSelect.addEventListener('change', (event) => {
const method = inputMethodSelect.value;
[pasteInputGroup, urlInputGroup, imageInputGroup, videoInputGroup, videoUrlInputGroup]
.forEach(el => el.classList.add('d-none'));
const groupMap = {
'paste': pasteInputGroup,
'url': urlInputGroup,
'image': imageInputGroup,
'video': videoInputGroup,
'video-url': videoUrlInputGroup
};
if(groupMap[method]) groupMap[method].classList.remove('d-none');
});

setupFileUploadDragAndDrop(imageUploadArea, imageInput, handleImageSelect);
setupFileUploadDragAndDrop(videoUploadArea, videoInput, handleVideoSelect);
processImageBtn.addEventListener('click', processImage);
processVideoBtn.addEventListener('click', processVideo);
transcribeVideoUrlBtn.addEventListener('click', transcribeVideoUrl);

fetchArticleBtn.addEventListener('click', async () => {
  let url = urlInput.value.trim();
  if (!url) {
    showToast('Please enter a valid URL.', 'info');
    return;
  }

  if (!url.match(/^https?:\/\/[^\s/$.?#].[^\s]*$/)) {
    showToast('Invalid URL format. Please use http:// or https://.', 'info');
    return;
  }

  toggleLoading(fetchArticleBtn, true, 'Fetching...');

  try {
    const response = await fetch(`/api/fetch-article`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url })
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || 'Failed to fetch article.');
    }

    if (!data.content || typeof data.content !== 'string') {
      showToast('No readable content extracted. Try paste manually.', 'info');
      return;
    }

    // ‚úÖ Convert HTML ‚Üí plain text (keeps paragraphs)
    const cleaned = (function stripHtml(html) {
      const doc = new DOMParser().parseFromString(html, "text/html");
      const paragraphs = doc.body.querySelectorAll("p, br");
      if (paragraphs.length) {
        return Array.from(paragraphs)
          .map(el => (el.tagName === "BR" ? "\n" : el.textContent || ""))
          .join("\n")
          .trim();
      }
      return (doc.body.textContent || "").trim();
    })(data.content);

    // ‚úÖ Insert into textarea
    textInput.value = cleaned;

    // ‚úÖ STORE THE URL IN MEMORY BEFORE SWITCHING UI
    currentSourceUrl = url;

    // ‚úÖ Switch UI to paste mode
    inputMethodSelect.value = 'paste';
    inputMethodSelect.dispatchEvent(new Event('change'));

    showToast('Article text has been fetched and pasted. If the text is long and Chrome AI mode is on, we suggest you summarize with Gemini Nano before Run Analysis', 'success');

  } catch (error) {
    console.error('Fetch error:', error);
    showToast(`Error fetching article: ${error.message}`, 'error');
  } finally {
    toggleLoading(fetchArticleBtn, false);
  }
});


analysisForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const articleText = textInput.value.trim();
    
    // ‚úÖ Logic: Use the captured URL if available, otherwise check the input box
    const finalSourceUrl = currentSourceUrl || (urlInput ? urlInput.value.trim() : null);

    if (!articleText) {
        showToast('Article text is empty. Please paste content or use one of the input methods.', 'info');
        return;
    }
    toggleLoading(runAnalysisBtn, true, 'Analyzing...');
    resultsContainer.innerHTML = '';
    generatedReports = [];
    
    try {
        const response = await fetch(`${API_BASE}/api/analyze`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                text: articleText,
                mode: promptModeSelect.value,
                usePapers: usePapersToggle.checked,
                // ‚úÖ Send the source URL to backend
                source_url: finalSourceUrl
            }),
        });
        const data = await response.json();
        
        // 1. Capture the backend cached flag
        const backendCached = !!data.cached;
        
        analysisId = data.analysis_id;   
        if (!response.ok) {
            const errorMessage = data.error || `Failed to analyze text: ${response.status}`;
            throw new Error(errorMessage);
        }
        if (data.claims.length === 0) {
            resultsContainer.innerHTML = '<div class="alert alert-info mt-4">No explicit claims found in the provided text.</div>';
            toggleLoading(runAnalysisBtn, false);
            return;
        }

        // 2. Pass the flag to the display function
        displayClaimsStructure(data.claims, backendCached);

        // 3. Removed applyCachedBadgesForClaims() call here

    } catch (error) {
        resultsContainer.innerHTML = `<div class="alert alert-danger mt-4">Error during analysis: ${error.message}</div>`;
        toggleLoading(runAnalysisBtn, false);
    }
});

downloadPdfBtn.addEventListener('click', openReportSelectionModal);

resultsContainer.addEventListener('click', async (e) => {
const targetBtn = e.target.closest('.generate-report-btn');
if (targetBtn) {
const { claimIdx, questionIdx, reportContainerId } = targetBtn.dataset;
generateReport(parseInt(claimIdx), parseInt(questionIdx), reportContainerId, targetBtn);
}
});
});

if ('serviceWorker' in navigator) {
window.addEventListener('load', () => {
navigator.serviceWorker.register('/static/service-worker.js')
.then(registration => {
console.log('Service Worker registered:', registration);
})
.catch(error => {
console.error('Service Worker registration failed:', error);
});
});
}

// ===== Chrome AI Local Pre-Processing (SAFE, Mode-Aware Persistent Cache) =====
document.addEventListener("DOMContentLoaded", () => {
  const textInput = document.getElementById("textInput");
  const chromeBtnContainer = document.getElementById("chrome-ai-text");
  const chromeInfo = document.getElementById("chrome-ai-info");
  const chromeModeDiv = document.getElementById("chrome-ai-mode");
  const chromeMode = document.getElementById("chromeMode");

  const chromeToggleEl = document.getElementById("enableChromeAiToggle");
const toggleSwitch = chromeToggleEl || { checked: true };

// --- Restore saved preference or default OFF ---
if (chromeToggleEl) {
    const saved = localStorage.getItem("ep_nano_enabled");

    if (saved === "1") chromeToggleEl.checked = true;
    else if (saved === "0") chromeToggleEl.checked = false;
    else chromeToggleEl.checked = false; // default first load
}

// --- Persist preference when user changes toggle ---
if (chromeToggleEl) {
    chromeToggleEl.addEventListener("change", () => {
        localStorage.setItem(
            "ep_nano_enabled",
            chromeToggleEl.checked ? "1" : "0"
        );
        updateChromeAiState();
    });
}

// Render UI based on the restored setting
updateChromeAiState();


  const undoBtn = document.getElementById("undo-nano-btn");

  const DEFAULT_BTN_TEXT = "üß† Summarize / Translate with Gemini Nano";
  let previousTextSnapshot = "";

  // ---------- Mode-aware persistent cache helpers ----------
  function nanoHash(text, mode) {
    const str = (mode || "") + "::" + text;
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = (h * 31 + str.charCodeAt(i)) | 0;
    }
    return "ep_nano_v1:" + h.toString(16);
  }

  function loadNanoCache(text, mode) {
    try {
      const key = nanoHash(text, mode);
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) {
      console.warn("Nano cache read failed:", e);
      return null;
    }
  }

  function saveNanoCache(text, mode, output, topics) {
    try {
      const key = nanoHash(text, mode);
      const payload = {
        output: output || "",
        topics: topics || ""
      };
      localStorage.setItem(key, JSON.stringify(payload));
    } catch (e) {
      console.warn("Nano cache write failed:", e);
    }
  }

  // ---------- Detect Chrome built-in AI ----------
  const hasChromeAI =
    (typeof self !== "undefined" && "Summarizer" in self) ||
    (window.ai && typeof window.ai.prompt === "function");

  if (!hasChromeAI) {
    console.info("‚ÑπÔ∏è Chrome AI not detected. Skipping local preprocessing.");
    return;
  }

  if (!textInput || !chromeBtnContainer || !chromeInfo) {
    // Defensive guard: required elements missing
    return;
  }

  chromeInfo.classList.remove("d-none");

  // ---------- Create the button ----------
  const btn = document.createElement("button");
  btn.className = "btn btn-warning w-100 fw-semibold";
  btn.textContent = DEFAULT_BTN_TEXT;
  chromeBtnContainer.appendChild(btn);

  // ---------- Toggle visibility (safe even without real toggle) ----------
  function updateChromeAiState() {
    const isEnabled = !!toggleSwitch.checked;

    if (isEnabled) {
      if (chromeModeDiv) chromeModeDiv.classList.remove("d-none");
      chromeBtnContainer.classList.remove("d-none");
      chromeInfo.style.opacity = "1";
    } else {
      if (chromeModeDiv) chromeModeDiv.classList.add("d-none");
      chromeBtnContainer.classList.add("d-none");
      chromeInfo.style.opacity = "0.7";
    }
  }

  if (chromeToggleEl) {
    chromeToggleEl.addEventListener("change", updateChromeAiState);
  }
  updateChromeAiState();

  // Auto-unlock when user edits text
  textInput.addEventListener("input", () => {
    if (btn.disabled && btn.textContent.includes("Processed")) {
      btn.disabled = false;
      btn.textContent = DEFAULT_BTN_TEXT;
      btn.className = "btn btn-warning w-100 fw-semibold";
      const topicsContainer = document.getElementById("nano-topics-container");
      if (topicsContainer) topicsContainer.classList.add("d-none");
    }
  });

  // ============================================================
  // AI HELPERS
  // ============================================================

  async function aiPromptNano(text) {
    if ("Summarizer" in self) {
      try {
        const summarizer = await Summarizer.create({
          outputLanguage: "en",
          type: "key-points",
          format: "markdown",
          length: "medium"
        });
        return await summarizer.summarize(text);
      } catch (err) {
        console.warn("Summarizer API failed", err);
      }
    }
    if (window.ai && typeof window.ai.prompt === "function") {
      try {
        const r = await window.ai.prompt(text);
        return r?.output ?? r?.text ?? String(r ?? "");
      } catch (err) {
        console.warn("window.ai.prompt failed", err);
      }
    }
    throw new Error("No local AI available");
  }

  async function summarizeIfLong(text, limit = 4000) {
    const mode = chromeMode?.value || "accurate";

    if (mode === "fast") {
      // Light-touch cleanup
      return await aiPromptNano("Fix formatting and remove artefacts:\n\n" + text);
    }

    let chunkPrefix = "Summarize clearly:\n\n";
    let finalPrefix = "Condense the following text into a clean English summary:\n\n";

    if (mode === "distill") {
      chunkPrefix = "Extract specific scientific claims, data, and numbers. Remove fluff:\n\n";
      finalPrefix = "Combine these points into a dense, factual list of claims for verification. Preserve numbers and citations:\n\n";
    }

    if (text.length <= limit) {
      return await aiPromptNano(finalPrefix + text);
    }

    const parts = [];
    for (let i = 0; i < text.length; i += limit) {
      parts.push(text.slice(i, i + limit));
    }

    const results = [];
    for (const part of parts) {
      try {
        results.push(await aiPromptNano(chunkPrefix + part));
      } catch (err) {
        console.warn("Chunk summarization failed", err);
      }
    }

    return await aiPromptNano(finalPrefix + results.join("\n\n"));
  }

  async function detectLang(text) {
    const out = await aiPromptNano(
      "Return only the ISO2 language code for this text:\n" + text.slice(0, 600)
    );
    return out.trim().toLowerCase().slice(0, 2) || "en";
  }

  async function translateIfNeeded(text) {
    const lang = await detectLang(text);
    if (lang === "en") return text;
    return await aiPromptNano("Translate the following text into English only:\n" + text);
  }

  async function extractKeywordsNano(text) {
    const context = text.slice(0, 3000);
    const prompt =
      "Analyze the following text and extract 5 to 7 specific scientific entities, concepts, or methodology terms. " +
      "Output strictly as a comma-separated list, no numbering.\nText:\n" + context;
    try {
      return await aiPromptNano(prompt);
    } catch (e) {
      console.warn("Keyword extraction failed", e);
      return "";
    }
  }

  function renderTopics(csvString) {
    const container = document.getElementById("nano-topics-container");
    const list = document.getElementById("nano-topics-list");
    if (!container || !list) return;

    if (!csvString || csvString.length < 3) {
      container.classList.add("d-none");
      return;
    }

    const topics = csvString
      .split(",")
      .map(t => t.replace(/^[-\*\s]+/, "").trim())
      .filter(t => t.length > 2 && t.length < 40);

    if (!topics.length) {
      container.classList.add("d-none");
      return;
    }

    list.innerHTML = topics
      .map(
        topic =>
          `<span class="badge bg-light text-secondary border me-1 mb-1" style="font-weight:500;">${topic}</span>`
      )
      .join("");

    container.classList.remove("d-none");
  }

  // ============================================================
  // MAIN BUTTON CLICK ‚Äî MODE-AWARE, PERSISTENT CACHE
  // ============================================================
  btn.addEventListener("click", async () => {
    if (!toggleSwitch.checked) return;

    let text = textInput.value.trim();
    if (!text) {
      showToast("No text present ‚Äî paste/extract/fetch first.", 'info');
      return;
    }

    const mode = chromeMode?.value || "accurate";

    // Always keep snapshot for Undo
    previousTextSnapshot = text;

    // ---------- CACHE FAST PATH ----------
    const cached = loadNanoCache(text, mode);
    if (cached && cached.output) {
      console.info("‚ú® Chrome AI cache hit");
      textInput.value = cached.output;
      renderTopics(cached.topics || "");

      // ‚úÖ Use Standardized HTML for the button label
      btn.innerHTML = `‚úÖ Processed ${getBadgeHtml('nano')}`;
      
      // Styling
      btn.className = "btn btn-success w-100 fw-semibold d-flex align-items-center justify-content-center gap-2";
      btn.disabled = true;
      
      if (undoBtn) undoBtn.classList.remove("d-none");
      return;
    }

    // ---------- PROCESSING PATH ----------
    const topicsContainer = document.getElementById("nano-topics-container");
    if (topicsContainer) topicsContainer.classList.add("d-none");
    if (undoBtn) undoBtn.classList.add("d-none");

    textInput.classList.add("textarea-dim");
    btn.disabled = true;
    btn.innerHTML = `‚è≥ <span class="ai-pulse"></span> Processing...`;

    let success = false;
    let finalText = "";
    let keywordResult = "";

    try {
      const keywordPromise = extractKeywordsNano(text);
      const summaryPromise = summarizeIfLong(text);

      const [resultText, keywords] = await Promise.all([
        summaryPromise,
        keywordPromise
      ]);

      keywordResult = keywords || "";
      const translated = await translateIfNeeded(resultText);
      finalText = translated.trim();

      // Update UI
      textInput.value = finalText;
      renderTopics(keywordResult);

      // Save to persistent cache
      saveNanoCache(text, mode, finalText, keywordResult);

      success = true;
    } catch (err) {
      console.error("Chrome AI error:", err);
      btn.innerHTML = "‚ö†Ô∏è Error (Click to retry)";
      btn.disabled = false;
    } finally {
      textInput.classList.remove("textarea-dim");
    }

    if (success) {
      btn.innerHTML = "‚úÖ Processed";
      btn.className = "btn btn-success w-100 fw-semibold";
      btn.disabled = true;
      if (undoBtn) undoBtn.classList.remove("d-none");
    }
  });

  // ---------- Undo ----------
  if (undoBtn) {
    undoBtn.addEventListener("click", (e) => {
      e.preventDefault();
      if (!previousTextSnapshot) return;

      textInput.value = previousTextSnapshot;
      const topicsContainer = document.getElementById("nano-topics-container");
      if (topicsContainer) topicsContainer.classList.add("d-none");

      undoBtn.classList.add("d-none");
      btn.disabled = false;
      btn.textContent = DEFAULT_BTN_TEXT;
      btn.className = "btn btn-warning w-100 fw-semibold";
    });
  }
});

// --- Claer Chrome Cache ---
function clearNanoCache() {
    for (let i = localStorage.length - 1; i >= 0; i--) {
        const key = localStorage.key(i);
        if (key && key.startsWith("ep_nano_v1:")) {
            localStorage.removeItem(key);
        }
    }

    showToast("Chrome AI cache cleared.", 'success');
}

document.getElementById("clearNanoCacheBtn_LoggedOut")?.addEventListener("click", clearNanoCache);
document.getElementById("clearNanoCacheBtn_LoggedIn")?.addEventListener("click", clearNanoCache);

// --- FAQ Buttons ---

document.getElementById("openFaqBtn_LoggedOut")?.addEventListener("click", () => {
    new bootstrap.Modal(document.getElementById("faqModal")).show();
});

document.getElementById("openFaqBtn_LoggedIn")?.addEventListener("click", () => {
    new bootstrap.Modal(document.getElementById("faqModal")).show();
});

  
</script>



<!-- ============================
     FAQ MODAL
============================= -->
<div class="modal fade" id="faqModal" tabindex="-1" aria-labelledby="faqModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">

      <div class="modal-header">
        <h5 class="modal-title fw-bold" id="faqModalLabel">Epistemiq ‚Äî FAQ</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>

      <div class="modal-body">

        <!-- Accordion -->
        <div class="accordion" id="faqAccordion">

          <!-- ============================
               SECTION A ‚Äî CORE CONCEPT
          ============================= -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="headingA">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseA">
                Section A ‚Äî Core Concept
              </button>
            </h2>
            <div id="collapseA" class="accordion-collapse collapse show" data-bs-parent="#faqAccordion">
              <div class="accordion-body">

                <h6 class="fw-bold mt-2">What is Epistemiq?</h6>
                <p>
                  Epistemiq is a browser-first misinformation defense tool. It extracts claims,
                  summarizes text locally using Chrome‚Äôs Gemini Nano, and verifies them using
                  a selection of cloud models, helping you quickly check scientific accuracy.
                </p>

                <h6 class="fw-bold mt-3">How does it work?</h6>
                <p>
                  Epistemiq combines <strong>local AI inside Chrome</strong> for preprocessing
                  (summarization, translation, keyword extraction) with a secure
                  <strong>cloud verifier</strong> for evidence-based analysis.
                  It never sends raw text to the cloud unless verification is explicitly triggered.
                </p>

                <h6 class="fw-bold mt-3">Is Epistemiq an AI chatbot?</h6>
                <p>
                  No. Epistemiq is not a conversational assistant.
                  It is an <strong>evidence engine</strong> that extracts claims, checks science,
                  pulls papers, and produces structured reports.
                </p>

                <h6 class="fw-bold mt-3">What models does Epistemiq use?</h6>
                <p>
                  ‚Ä¢ <strong>Gemini Nano (browser built-in)</strong> for summarization, translation, cleanup  
                  ‚Ä¢ <strong>Various LLM models via OpenRouter</strong> for claim verification  
                  ‚Ä¢ <strong>Semantic Scholar, CrossRef + PubMed</strong> for retrieving academic literature  
                </p>

              </div>
            </div>
          </div>

          <!-- ============================
               SECTION B ‚Äî PRIVACY
          ============================= -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="headingB">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseB">
                Section B ‚Äî Privacy + Local Processing
              </button>
            </h2>
            <div id="collapseB" class="accordion-collapse collapse" data-bs-parent="#faqAccordion">
              <div class="accordion-body">

                <h6 class="fw-bold mt-2">Does Epistemiq send my text to the cloud?</h6>
                <p>
                  Not automatically. Epistemiq keeps preprocessing fully local.
                  Raw text leaves your device <strong>only if you explicitly run analysis</strong>.
                </p>

                <h6 class="fw-bold mt-3">What is Chrome‚Äôs Gemini Nano and why does Epistemiq use it?</h6>
                <p>
                  Gemini Nano is a small on-device AI model built into Chrome.  
                  Epistemiq uses it for:
                  <br>‚Ä¢ Summarization  
                  <br>‚Ä¢ Translation  
                  <br>‚Ä¢ Keyword extraction  
                  <br>
                  This keeps preprocessing local (in your browser), offline-capable, and preserves privacy.
                </p>

                <h6 class="fw-bold mt-3">When is cloud verification used?</h6>
                <p>
                  Only during the ‚ÄúRun Analysis‚Äù step.  
                  At that moment, extracted claims are sent to OpenRouter‚Äôs LLM model
                  to check for accuracy, uncertainty, and available evidence.
                </p>

              </div>
            </div>
          </div>

          <!-- ============================
               SECTION C ‚Äî USAGE
          ============================= -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="headingC">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseC">
                Section C ‚Äî Usage Instructions
              </button>
            </h2>
            <div id="collapseC" class="accordion-collapse collapse" data-bs-parent="#faqAccordion">
              <div class="accordion-body">

                <h6 class="fw-bold mt-2">How do I analyze an article or video?</h6>
                <p>
                  Paste a URL ‚Üí Extract text ‚Üí (Optional) summarize with Chrome AI ‚Üí
                  Run Analysis ‚Üí Explore evidence.
                </p>

                <h6 class="fw-bold mt-3">How do I paste text instead of a URL?</h6>
                <p>
                  Simply paste any text into the input box.  
                  Chrome AI will preprocess it, and the cloud verifier will analyze it.
                </p>

                <h6 class="fw-bold mt-3">How do I undo a summarization?</h6>
                <p>
                  Tap the <strong>Undo</strong> button that appears after Nano processing.
                </p>

                <h6 class="fw-bold mt-3">Can I use different summarization modes?</h6>
                <p>
                  Yes ‚Äî Epistemiq supports:
                  <br>‚Ä¢ Standard (accurate)
                  <br>‚Ä¢ Fast (simple cleanup)
                  <br>‚Ä¢ Distill (extract scientific claims only)
                </p>

                <h6 class="fw-bold mt-3">How do I access my analysis history?</h6>
                <p>
                  Open the History panel from the top navigation.
                  You can reopen, delete, and inspect past analyses.
                </p>

              </div>
            </div>
          </div>

          <!-- ============================
               SECTION D ‚Äî TECHNICAL
          ============================= -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="headingD">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseD">
                Section D ‚Äî Technical Questions
              </button>
            </h2>
            <div id="collapseD" class="accordion-collapse collapse" data-bs-parent="#faqAccordion">
              <div class="accordion-body">

                <h6 class="fw-bold mt-2">Why is analysis sometimes slow?</h6>
                <p>
                  ‚Ä¢ Very large input text  
                  ‚Ä¢ Limited mobile CPU for on-device AI  
                  ‚Ä¢ OpenRouter rate limits  
                  ‚Ä¢ Semantic Scholar/CrossRef/PubMed lookup time  
                </p>

                <h6 class="fw-bold mt-3">Why do some claims say ‚Äúuncertain‚Äù?</h6>
                <p>
                  The model marks claims as uncertain when scientific consensus is mixed,
                  evidence is weak, or contradictory studies exist.
                </p>

                <h6 class="fw-bold mt-3">Why do I get 429 / rate-limits?</h6>
                <p>
                  Free OpenRouter key ‚Üí shared rate-limit pool. Try later.              
                </p>

                
              </div>
            </div>
          </div>

          <!-- ============================
               VIDEO PLACEHOLDER
          ============================= -->
          <div class="mt-4">
            <h6 class="fw-bold">Demo Video</h6>
            <div class="ratio ratio-16x9 rounded border bg-light">
              <!-- Replace this when ready -->
              <iframe 
                src="https://www.youtube.com/embed/XXXXXXXXXXX" 
                allowfullscreen
                style="border:0;">
              </iframe>
            </div>
            <p class="text-muted small mt-1">
              Video walkthrough coming soon.
            </p>
          </div>

        </div> <!-- end accordion -->

      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>

    </div>
  </div>
</div>

<!-- Toast Container -->
<div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 3000;">
  <!-- Toasts get injected here by JS -->
</div>
  
</body>
</html>
